<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Dynamic ID Card Generator - Create Professional ID Cards Online</title>

    <meta name="keywords"
        content="ID card generator, dynamic ID cards, CSV data, batch ID cards, employee ID cards, student ID cards, professional ID cards, barcode generator, custom templates, drag and drop, photo ID cards, bulk ID cards, ID card maker, online ID generator, web-based ID cards, ID card design, custom fonts, layout editor, ZIP download, real-time preview" />
    <meta name="description"
        content="Create professional ID cards dynamically using CSV data and customizable templates. Upload your template, import CSV data, and generate multiple ID cards with photos, names, barcodes, and custom styling. Perfect for organizations, schools, companies, and events. No installation required - runs entirely in your browser.">

    <meta property="og:title" content="Dynamic ID Card Generator - Create Professional ID Cards Online">
    <meta property="og:description" content="Generate multiple professional ID cards from CSV data with drag-and-drop design tools, custom templates, and batch processing.">
    <meta property="og:type" content="website">
    <meta property="og:image" content="apple-touch-icon.png">
    <meta property="og:url" content="index.html">

    <!-- Favicon -->
    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
    <link rel="apple-touch-icon" href="apple-touch-icon.png">

    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <div class="container">
        <header class="header">
            <h1>ID Card Generator</h1>
            <p>Create stunning professional ID cards with photos, names, IDs, and barcodes. Upload your template and CSV
                data to get started with our intuitive drag-and-drop interface.</p>
        </header>

        <div class="actions-bar">
            <button class="btn btn-secondary" onclick="selectFile('template')" id="templateBtn">
                <div class="btn-text">
                    <span>üñºÔ∏è</span>
                    <span id="templateBtnText">Template Image</span>
                </div>
                <div id="templateFileName" class="file-name-display" style="display: none;"></div>
            </button>

            <button class="btn btn-secondary" onclick="selectFile('csv')" id="csvBtn">
                <div class="btn-text">
                    <span>üìä</span>
                    <span id="csvBtnText">CSV Data</span>
                </div>
                <div id="csvFileName" class="file-name-display csv" style="display: none;"></div>
            </button>

            <button class="btn btn-primary" onclick="processCSV()">
                <div class="btn-text">
                    <span>‚ú®</span>
                    Generate Cards
                </div>
            </button>

            <button class="btn btn-secondary" onclick="exportLayout()">
                <div class="btn-text">
                    <span>üì§</span>
                    Export Layout
                </div>
            </button>

            <button class="btn btn-secondary" onclick="saveLayoutLocal()">
                <div class="btn-text">
                    <span>üíæ</span>
                    Save Layout
                </div>
            </button>

            <button class="btn btn-success" onclick="downloadAllZip()">
                <div class="btn-text">
                    <span>üì¶</span>
                    Download ZIP
                </div>
            </button>

            <button class="btn btn-secondary" onclick="selectFile('layout')" id="layoutBtn">
                <div class="btn-text">
                    <span>üì•</span>
                    <span id="layoutBtnText">Import Layout</span>
                </div>
                <div id="layoutFileName" class="file-name-display layout" style="display: none;"></div>
            </button>
        </div>

        <div class="main-layout">
            <div class="card">
                <div class="card-header">
                    <h2>
                        <span>üé®</span>
                        Template & Controls
                    </h2>
                </div>
                <div class="card-content">
                    <div class="toggle-group">
                        <label>
                            <span class="toggle">
                                <input id="snapToggle" type="checkbox" checked>
                                <span class="slider"></span>
                            </span>
                            Snap to Grid
                        </label>

                        <label>
                            Grid Size:
                            <input id="gridSize" type="number" value="10" class="form-input"
                                style="width: 80px; margin-left: 0.5rem;">
                        </label>

                        <label>
                            <span class="toggle">
                                <input id="showOverlaysInput" type="checkbox" checked onchange="toggleOverlayLabels()">
                                <span class="slider"></span>
                            </span>
                            Show Overlays
                        </label>
                    </div>

                    <div class="controls-grid">
                        <div class="settings-section">
                            <div class="section-title">
                                <span>üîó</span>
                                CSV Field Mapping
                            </div>
                            <p style="color: var(--gray-600); margin-bottom: 1.5rem; font-size: 0.9rem;">
                                Map your CSV columns to card elements. Upload your CSV file first to see available
                                columns.
                            </p>

                            <div class="mapping-section">
                                <div class="mapping-row">
                                    <span class="mapping-label">Photo:</span>
                                    <select id="mapPhoto" class="form-input">
                                        <option value="">‚Äî none ‚Äî</option>
                                    </select>
                                </div>

                                <div class="mapping-row">
                                    <span class="mapping-label">Name:</span>
                                    <select id="mapName" class="form-input">
                                        <option value="">‚Äî none ‚Äî</option>
                                    </select>
                                </div>

                                <div class="mapping-row">
                                    <span class="mapping-label">ID/Roll:</span>
                                    <select id="mapID" class="form-input">
                                        <option value="">‚Äî none ‚Äî</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                        <div class="control-group" id="row-photo" data-el="photo">
                            <div class="control-icon">üì∑</div>
                            <div class="control-info">
                                <div class="control-label">
                                    Photo
                                    <span id="label-photo" class="status-indicator status-unmapped">Unmapped</span>
                                </div>
                                <div class="control-coords">
                                    X: <input class="pos-input coord-input" id="photoX_input" type="number">
                                    Y: <input class="pos-input coord-input" id="photoY_input" type="number">
                                </div>
                            </div>
                            <div class="control-actions">
                                <button class="control-btn" onclick="enterPlaceMode('photo')">Place</button>
                                <button class="control-btn" onclick="nudgeElement('photo',0,-1)">‚ñ≤</button>
                                <button class="control-btn" onclick="nudgeElement('photo',0,1)">‚ñº</button>
                            </div>
                        </div>

                        <div class="control-group" id="row-name" data-el="name">
                            <div class="control-icon">üë§</div>
                            <div class="control-info">
                                <div class="control-label">
                                    Name
                                    <span id="label-name" class="status-indicator status-unmapped">Unmapped</span>
                                </div>
                                <div class="control-coords">
                                    X: <input class="pos-input coord-input" id="nameX_input" type="number">
                                    Y: <input class="pos-input coord-input" id="nameY_input" type="number">
                                </div>
                            </div>
                            <div class="control-actions">
                                <button class="control-btn" onclick="enterPlaceMode('name')">Place</button>
                                <button class="control-btn" onclick="nudgeElement('name',0,-1)">‚ñ≤</button>
                                <button class="control-btn" onclick="nudgeElement('name',0,1)">‚ñº</button>
                            </div>
                        </div>

                        <div class="control-group" id="row-roll" data-el="roll">
                            <div class="control-icon">üÜî</div>
                            <div class="control-info">
                                <div class="control-label">
                                    Roll / ID
                                    <span id="label-roll" class="status-indicator status-unmapped">Unmapped</span>
                                </div>
                                <div class="control-coords">
                                    X: <input class="pos-input coord-input" id="rollX_input" type="number">
                                    Y: <input class="pos-input coord-input" id="rollY_input" type="number">
                                </div>
                            </div>
                            <div class="control-actions">
                                <button class="control-btn" onclick="enterPlaceMode('roll')">Place</button>
                                <button class="control-btn" onclick="nudgeElement('roll',0,-1)">‚ñ≤</button>
                                <button class="control-btn" onclick="nudgeElement('roll',0,1)">‚ñº</button>
                            </div>
                        </div>

                        <div class="control-group" id="row-barcode" data-el="barcode">
                            <div class="control-icon">üî¢</div>
                            <div class="control-info">
                                <div class="control-label">
                                    Barcode
                                    <span id="label-barcode" class="status-indicator status-unmapped">Unmapped</span>
                                </div>
                                <div class="control-coords">
                                    X: <input class="pos-input coord-input" id="barcodeX_input" type="number">
                                    Y: <input class="pos-input coord-input" id="barcodeY_input" type="number">
                                </div>
                            </div>
                            <div class="control-actions">
                                <button class="control-btn" onclick="enterPlaceMode('barcode')">Place</button>
                                <button class="control-btn" onclick="nudgeElement('barcode',0,-1)">‚ñ≤</button>
                                <button class="control-btn" onclick="nudgeElement('barcode',0,1)">‚ñº</button>
                            </div>
                        </div>

                    </div>

                    <div class="form-group">
                        <label class="form-label">Photo Size</label>
                        <input id="photoSize_input" type="range" min="16" max="400" value="80" class="range-input"
                            oninput="updatePhotoSizeFromSlider(this.value)">
                    </div>
                </div>
            </div>

            <div class="preview-section">
                <div class="card-header">
                    <h2>
                        <span>üëÅÔ∏è</span>
                        Live Preview
                    </h2>
                </div>
                <div class="canvas-container">
                    <div class="canvas-overlay">
                        <button class="overlay-btn" onclick="toggleOverlayLabels()">
                            üëÅÔ∏è Overlays
                        </button>
                        <button class="overlay-btn" onclick="snapAllToGrid()">
                            üìê Snap to Grid
                        </button>
                    </div>
                    <canvas id="preview" width="420" height="600"></canvas>
                </div>
            </div>

            <div class="card">
                <div class="card-header">
                    <div class="section-title">
                        <span>‚öôÔ∏è</span>
                        Active Element: <span id="activeField" style="color: var(--primary);">Photo</span>
                    </div>

                    <div class="form-grid">
                        <div class="form-group">
                            <label class="form-label">Font Family</label>
                            <div class="font-controls">
                                <select id="fontFamily" class="form-input">
                                    <option value="Arial">Arial</option>
                                    <option value="Roboto">Roboto</option>
                                    <option value="Inter">Inter</option>
                                    <option value="Open Sans">Open Sans</option>
                                    <option value="Lato">Lato</option>
                                    <option value="Times New Roman">Times New Roman</option>
                                    <option value="Georgia">Georgia</option>
                                </select>
                                <button type="button" class="font-upload-btn" onclick="showFontOptions()">
                                    üìÅ Add Font
                                </button>
                            </div>
                            <input type="url" id="fontUrl" class="font-url-input"
                                placeholder="Or paste Google Fonts URL..." style="display: none;">
                        </div>

                        <div class="form-group">
                            <label class="form-label">Font Size (px)</label>
                            <input id="fontSize" type="number" value="20" class="form-input">
                        </div>

                        <div class="form-group">
                            <label class="form-label">Font Weight</label>
                            <select id="fontWeight" class="form-input">
                                <option value="400">Normal</option>
                                <option value="700">Bold</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Font Style</label>
                            <select id="fontStyle" class="form-input">
                                <option value="normal">Normal</option>
                                <option value="italic">Italic</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Text Color</label>
                            <input id="fontColor" type="color" value="#000000" class="color-input">
                        </div>

                        <div class="form-group">
                            <label class="form-label">Line Height (px)</label>
                            <input id="lineHeight" type="number" value="22" class="form-input">
                        </div>

                        <div class="form-group">
                            <label class="form-label">Max Width (px)</label>
                            <input id="maxWidth" type="number" value="300" class="form-input">
                        </div>

                        <div class="form-group">
                            <label class="form-label">Text Alignment</label>
                            <select id="textAlign" class="form-input">
                                <option value="left">Left</option>
                                <option value="center">Center</option>
                                <option value="right">Right</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Auto-fit Font</label>
                            <select id="autoFit" class="form-input">
                                <option value="1">Enabled</option>
                                <option value="0">Disabled</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Max Lines</label>
                            <input id="maxLines" type="number" value="2" min="1" max="10" class="form-input">
                        </div>
                    </div>

                    <div style="margin-top: 1.5rem; display: flex; gap: 1rem;">
                        <button class="btn btn-primary" onclick="applyStyleToActive()">Apply to Active</button>
                        <button class="btn btn-secondary" onclick="applyStyleToAll()">Apply to All Text</button>
                    </div>
                </div>

                <div class="settings-section">
                    <div class="section-title">
                        <span>üì∑</span>
                        Photo Controls
                    </div>

                    <div class="form-grid">
                        <div class="form-group">
                            <label class="form-label">Photo Size (px)</label>
                            <input id="photoSize" type="number" value="80" class="form-input">
                        </div>

                        <div class="form-group">
                            <label class="form-label">Shape</label>
                            <select id="photoShape" class="form-input">
                                <option value="circle">Circle</option>
                                <option value="rectangle">Rectangle</option>
                                <option value="rounded">Rounded</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Border Width (px)</label>
                            <input id="photoBorder" type="number" value="0" class="form-input">
                        </div>

                        <div class="form-group">
                            <label class="form-label">Border Color</label>
                            <input id="photoBorderColor" type="color" value="#ffffff" class="color-input">
                        </div>

                        <div class="form-group">
                            <label class="form-label">Border Radius (px)</label>
                            <input id="photoRadius" type="number" value="12" class="form-input">
                        </div>
                    </div>
                </div>

                <div class="settings-section">
                    <div class="section-title">
                        <span>üî¢</span>
                        Barcode Controls
                    </div>

                    <div class="form-grid">
                        <div class="form-group">
                            <label class="form-label">Barcode Source</label>
                            <select id="mapBarcode" class="form-input">
                                <option value="">‚Äî none ‚Äî</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Width (px)</label>
                            <input id="barcodeW" type="number" value="300" class="form-input">
                        </div>

                        <div class="form-group">
                            <label class="form-label">Height (px)</label>
                            <input id="barcodeH" type="number" value="60" class="form-input">
                        </div>

                        <div class="form-group">
                            <label class="form-label">Format</label>
                            <select id="barcodeFormat" class="form-input">
                                <option value="CODE128">CODE128</option>
                                <option value="EAN13">EAN13</option>
                                <option value="EAN8">EAN8</option>
                                <option value="UPC">UPC</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div class="settings-section">
                    <div class="section-title">
                        <span>üìê</span>
                        Card Dimensions
                    </div>

                    <div class="form-grid">
                        <div class="form-group">
                            <label class="form-label">Card Width (px)</label>
                            <input id="cardW" type="number" value="800" class="form-input">
                        </div>

                        <div class="form-group">
                            <label class="form-label">Card Height (px)</label>
                            <input id="cardH" type="number" value="1200" class="form-input">
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="card cards-section">
            <div class="card-header">
                <h2>
                    <span>üé¥</span>
                    Generated Card Previews
                </h2>
            </div>
            <div class="card-content">
                <div class="preview-grid" id="cardsContainer">
                    <!-- Generated cards will appear here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden file inputs -->
    <input id="templateFile" type="file" accept="image/*" style="display: none;">
    <input id="csvFile" type="file" accept=".csv" style="display: none;">
    <input id="layoutFile" type="file" accept=".json" style="display: none;">
    <input id="fontFile" type="file" accept=".ttf,.otf,.woff,.woff2" style="display: none;">

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.0/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsbarcode@3.11.5/dist/JsBarcode.all.min.js"></script>

    <script>
        let templateImage = null;
        let csvHeaders = [];
        let csvRows = [];
        let selectedElement = 'photo';
        let placingElement = null;
        let showOverlays = true;
        let customFonts = {};

        const defaultLayout = {
            cardW: 800, cardH: 1200,
            photoX: 400, photoY: 180, photoSize: 80, photoShape: 'circle', photoBorder: 0, photoBorderColor: '#ffffff', photoRadius: 12,
            nameX: 80, nameY: 400, nameSize: 28, nameFamily: 'Arial', nameWeight: 700, nameStyle: 'normal', nameColor: '#000000', nameLine: 36, nameMaxWidth: 500, nameAlign: 'left', nameMaxLines: 2,
            rollX: 80, rollY: 460, rollSize: 20, rollFamily: 'Arial', rollWeight: 400, rollStyle: 'normal', rollColor: '#000000', rollLine: 24, rollMaxWidth: 300, rollAlign: 'left',
            barcodeX: 80, barcodeY: 520, barcodeW: 300, barcodeH: 60, barcodeFormat: 'CODE128'
        };
        let layout = JSON.parse(JSON.stringify(defaultLayout));

        const preview = document.getElementById('preview');
        const pctx = preview.getContext('2d');
        function $(id) { return document.getElementById(id); }

        // File name display functions
        function updateFileNameDisplay(type, fileName) {
            const displays = {
                template: {
                    display: $('templateFileName'),
                    icon: 'üñºÔ∏è'
                },
                csv: {
                    display: $('csvFileName'),
                    icon: 'üìä'
                },
                layout: {
                    display: $('layoutFileName'),
                    icon: 'üì•'
                }
            };

            const config = displays[type];
            if (config && config.display) {
                if (fileName) {
                    config.display.innerHTML = `<span class="file-icon">${config.icon}</span>${fileName}`;
                    config.display.style.display = 'flex';
                } else {
                    config.display.style.display = 'none';
                }
            }
        }

        // Progress bar functions
        function showProgressModal() {
            const modal = document.createElement('div');
            modal.className = 'progress-modal';
            modal.id = 'progressModal';
            modal.innerHTML = `
                <div class="progress-content">
                    <h3 style="margin-bottom: 1rem; color: var(--gray-900);">Creating ZIP Archive</h3>
                    <div class="progress-text" id="progressText">Preparing files...</div>
                    <div class="progress-bar-container">
                        <div class="progress-bar" id="progressBar"></div>
                    </div>
                    <div class="progress-stats" id="progressStats">0 of 0 cards processed</div>
                </div>
            `;
            document.body.appendChild(modal);
            return modal;
        }

        function updateProgress(current, total, status = '') {
            const progressBar = $('progressBar');
            const progressText = $('progressText');
            const progressStats = $('progressStats');

            if (progressBar && progressText && progressStats) {
                const percentage = total > 0 ? Math.round((current / total) * 100) : 0;
                progressBar.style.width = percentage + '%';
                progressText.textContent = status || `Processing card ${current} of ${total}`;
                progressStats.textContent = `${current} of ${total} cards processed`;
            }
        }

        function hideProgressModal() {
            const modal = $('progressModal');
            if (modal) {
                modal.remove();
            }
        }

        // Fixed file selection function to prevent double popups
        function selectFile(type) {
            let input;
            switch (type) {
                case 'template':
                    input = $('templateFile');
                    break;
                case 'csv':
                    input = $('csvFile');
                    break;
                case 'layout':
                    input = $('layoutFile');
                    break;
                case 'font':
                    input = $('fontFile');
                    break;
                default:
                    return;
            }

            if (input) {
                input.click();
            }
        }

        // Fixed font options function
        function showFontOptions() {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10000;
            `;

            const content = document.createElement('div');
            content.style.cssText = `
                background: white;
                padding: 2rem;
                border-radius: 1rem;
                box-shadow: 0 25px 50px -12px rgba(0,0,0,0.25);
                max-width: 400px;
                width: 90%;
            `;

            content.innerHTML = `
                <h3 style="margin-bottom: 1.5rem; color: var(--gray-900); font-size: 1.25rem;">Add Custom Font</h3>
                <div style="display: grid; gap: 1rem;">
                    <button onclick="selectFile('font'); closeModal()" class="btn btn-primary" style="justify-content: center;">
                        üìÅ Upload Font File (.ttf, .otf, .woff)
                    </button>
                    <button onclick="showUrlInput()" class="btn btn-secondary" style="justify-content: center;">
                        üîó Load from Google Fonts URL
                    </button>
                    <button onclick="closeModal()" class="btn btn-secondary" style="justify-content: center;">
                        ‚ùå Cancel
                    </button>
                </div>
            `;

            modal.appendChild(content);
            document.body.appendChild(modal);

            window.closeModal = () => document.body.removeChild(modal);
            window.showUrlInput = () => {
                const urlInput = document.createElement('input');
                urlInput.type = 'url';
                urlInput.placeholder = 'https://fonts.googleapis.com/css2?family=...';
                urlInput.style.cssText = `
                    width: 100%;
                    padding: 0.75rem;
                    border: 2px solid var(--gray-300);
                    border-radius: 0.5rem;
                    margin: 1rem 0;
                `;

                const submitBtn = document.createElement('button');
                submitBtn.textContent = 'Load Font';
                submitBtn.className = 'btn btn-primary';
                submitBtn.style.cssText = 'width: 100%; justify-content: center; margin-top: 0.5rem;';
                submitBtn.onclick = () => {
                    if (urlInput.value) {
                        loadFontFromUrl(urlInput.value);
                        closeModal();
                    }
                };

                content.innerHTML = `
                    <h3 style="margin-bottom: 1.5rem; color: var(--gray-900); font-size: 1.25rem;">Load Font from URL</h3>
                    <p style="margin-bottom: 1rem; color: var(--gray-600); font-size: 0.9rem;">
                        Paste a Google Fonts CSS URL or any other font CSS URL:
                    </p>
                `;
                content.appendChild(urlInput);
                content.appendChild(submitBtn);

                const cancelBtn = document.createElement('button');
                cancelBtn.textContent = 'Cancel';
                cancelBtn.className = 'btn btn-secondary';
                cancelBtn.style.cssText = 'width: 100%; justify-content: center; margin-top: 0.5rem;';
                cancelBtn.onclick = closeModal;
                content.appendChild(cancelBtn);
            };
        }

        // Notification system
        function showNotification(message, type = 'success') {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.innerHTML = `
                <div style="display: flex; align-items: center; gap: 0.75rem;">
                    <span style="font-size: 1.2rem;">${type === 'success' ? '‚úÖ' : type === 'error' ? '‚ùå' : '‚ö†Ô∏è'}</span>
                    <span style="font-weight: 500;">${message}</span>
                </div>
            `;
            document.body.appendChild(notification);

            setTimeout(() => notification.classList.add('show'), 100);
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => notification.remove(), 300);
            }, 4000);
        }

        // Font loading functions
        function loadCustomFont(event) {
            const file = event.target.files[0];
            if (!file) return;

            updateFileNameDisplay('font', file.name);

            const reader = new FileReader();
            reader.onload = function (e) {
                const fontName = file.name.replace(/\.[^/.]+$/, "");
                const fontFace = new FontFace(fontName, e.target.result);

                fontFace.load().then(function (loadedFont) {
                    document.fonts.add(loadedFont);
                    customFonts[fontName] = fontName;

                    const select = $('fontFamily');
                    const option = new Option(fontName, fontName);
                    select.add(option);
                    select.value = fontName;

                    showNotification(`Font "${fontName}" loaded successfully!`);
                    applyStyleToActive();
                }).catch(function (error) {
                    console.error('Font loading failed:', error);
                    showNotification('Failed to load font file', 'error');
                });
            };
            reader.readAsArrayBuffer(file);
        }

        function loadFontFromUrl(url) {
            if (!url) return;

            const link = document.createElement('link');
            link.rel = 'stylesheet';
            link.href = url;

            link.onload = function () {
                const fontMatch = url.match(/family=([^&:]+)/);
                if (fontMatch) {
                    const fontName = decodeURIComponent(fontMatch[1]).replace(/\+/g, ' ');
                    customFonts[fontName] = fontName;

                    const select = $('fontFamily');
                    const option = new Option(fontName, fontName);
                    select.add(option);
                    select.value = fontName;

                    showNotification(`Font "${fontName}" loaded from URL!`);
                    applyStyleToActive();
                }
            };

            link.onerror = function () {
                showNotification('Failed to load font from URL', 'error');
            };

            document.head.appendChild(link);
        }

        // File upload handlers
        $('templateFile').addEventListener('change', function (e) {
            const f = e.target.files[0];
            if (!f) return;

            updateFileNameDisplay('template', f.name);

            const reader = new FileReader();
            reader.onload = ev => {
                templateImage = new Image();
                templateImage.onload = () => {
                    const maxW = 420, maxH = 600;
                    const scale = Math.min(maxW / templateImage.width, maxH / templateImage.height, 1);
                    preview.width = Math.round(templateImage.width * scale);
                    preview.height = Math.round(templateImage.height * scale);
                    $('cardW').value = templateImage.width;
                    $('cardH').value = templateImage.height;
                    drawPreview();
                    populateLeftInputsFromLayout();
                    showNotification('Template image loaded successfully!');
                };
                templateImage.src = ev.target.result;
            };
            reader.readAsDataURL(f);
        });

        $('csvFile').addEventListener('change', (e) => {
            const f = e.target.files[0];
            if (!f) return;

            updateFileNameDisplay('csv', f.name);

            Papa.parse(f, {
                header: true,
                skipEmptyLines: true,
                complete: (res) => {
                    csvRows = res.data;
                    csvHeaders = res.meta.fields || Object.keys(csvRows[0] || {});
                    populateMappingDropdowns();
                    livePreview();
                    showNotification(`CSV loaded with ${csvRows.length} records!`);
                }
            });
        });

        $('layoutFile').addEventListener('change', function (e) {
            const f = e.target.files[0];
            if (!f) return;

            updateFileNameDisplay('layout', f.name);

            const r = new FileReader();
            r.onload = ev => {
                try {
                    const obj = JSON.parse(ev.target.result);
                    if (!obj.layout) {
                        showNotification('Invalid layout file - missing layout object', 'error');
                        return;
                    }

                    layout = Object.assign({}, layout, obj.layout);

                    if (obj.maps) {
                        if ($('mapPhoto')) $('mapPhoto').value = obj.maps.photo || '';
                        if ($('mapName')) $('mapName').value = obj.maps.name || '';
                        if ($('mapID')) $('mapID').value = obj.maps.id || '';
                        if ($('mapBarcode')) $('mapBarcode').value = obj.maps.barcode || '';
                    }

                    populateLeftInputsFromLayout();
                    updateMappingStatus();
                    drawPreview();
                    livePreview();
                    showNotification('Layout imported successfully!');
                } catch (err) {
                    console.error(err);
                    showNotification('Invalid JSON file', 'error');
                }
            };
            r.readAsText(f);
        });

        $('fontFile').addEventListener('change', loadCustomFont);

        function populateMappingDropdowns() {
            const selects = {
                mapPhoto: $('mapPhoto'),
                mapName: $('mapName'),
                mapID: $('mapID'),
                mapBarcode: $('mapBarcode')
            };

            Object.values(selects).forEach(s => {
                if (!s) return;
                s.innerHTML = '<option value="">‚Äî none ‚Äî</option>';
                csvHeaders.forEach(h => s.insertAdjacentHTML('beforeend', `<option value="${h}">${h}</option>`));
            });

            function trySet(id, names) {
                const found = csvHeaders.find(h => names.includes(h.toLowerCase()));
                if (found && $(id)) $(id).value = found;
            }

            trySet('mapPhoto', ['profile', 'photo', 'image', 'picture', 'img', 'profilepicture', 'profile_image', 'profile_pic']);
            trySet('mapName', ['name', 'studentname', 'full_name', 'fullname']);
            trySet('mapID', ['id', 'rollno', 'roll', 'studentid', 'instituteid']);

            if ($('mapID') && $('mapBarcode')) $('mapBarcode').value = $('mapID').value || '';

            updateMappingStatus();
        }

        function updateMappingStatus() {
            const mappings = {
                'label-photo': $('mapPhoto')?.value,
                'label-name': $('mapName')?.value,
                'label-roll': $('mapID')?.value,
                'label-barcode': $('mapBarcode')?.value
            };

            Object.entries(mappings).forEach(([labelId, value]) => {
                const label = $(labelId);
                if (label) {
                    if (value) {
                        label.textContent = 'Mapped';
                        label.className = 'status-indicator status-mapped';
                    } else {
                        label.textContent = 'Unmapped';
                        label.className = 'status-indicator status-unmapped';
                    }
                }
            });
        }

        function drawPreview() {
            pctx.clearRect(0, 0, preview.width, preview.height);
            if (templateImage) {
                pctx.drawImage(templateImage, 0, 0, preview.width, preview.height);
            } else {
                pctx.fillStyle = '#fff';
                pctx.fillRect(0, 0, preview.width, preview.height);
            }

            if ($('snapToggle').checked) drawGrid();
            if (showOverlays) drawOverlays();
        }

        function drawGrid() {
            const grid = parseInt($('gridSize').value) || 10;
            pctx.save();
            pctx.globalAlpha = 0.08;
            pctx.strokeStyle = '#667eea';
            pctx.lineWidth = 1;

            for (let x = 0; x < preview.width; x += grid) {
                pctx.beginPath();
                pctx.moveTo(x, 0);
                pctx.lineTo(x, preview.height);
                pctx.stroke();
            }

            for (let y = 0; y < preview.height; y += grid) {
                pctx.beginPath();
                pctx.moveTo(0, y);
                pctx.lineTo(preview.width, y);
                pctx.stroke();
            }
            pctx.restore();
        }

        function actualToPreview(ax, ay) {
            if (!templateImage) return { x: ax, y: ay };
            const sx = preview.width / templateImage.width;
            const sy = preview.height / templateImage.height;
            return { x: Math.round(ax * sx), y: Math.round(ay * sy) };
        }

        function previewToActual(px, py) {
            if (!templateImage) return { x: px, y: py };
            const sx = templateImage.width / preview.width;
            const sy = templateImage.height / preview.height;
            return { x: Math.round(px * sx), y: Math.round(py * sy) };
        }

        function drawOverlays() {
            if (!templateImage) return;
            const scale = preview.width / templateImage.width;

            // Photo overlay
            const p = actualToPreview(layout.photoX || defaultLayout.photoX, layout.photoY || defaultLayout.photoY);
            const psize = layout.photoSize || defaultLayout.photoSize;
            const r = Math.round(psize * scale);

            pctx.save();
            pctx.globalAlpha = 0.3;
            pctx.fillStyle = selectedElement === 'photo' ? '#667eea' : '#ef4444';

            if (layout.photoShape === 'circle') {
                pctx.beginPath();
                pctx.arc(p.x, p.y, r, 0, Math.PI * 2);
                pctx.fill();
            } else {
                pctx.fillRect(p.x - r, p.y - r, r * 2, r * 2);
            }
            pctx.restore();

            // Photo border
            pctx.save();
            pctx.lineWidth = selectedElement === 'photo' ? 3 : 2;
            pctx.strokeStyle = selectedElement === 'photo' ? '#667eea' : 'rgba(0,0,0,0.3)';

            if (layout.photoShape === 'circle') {
                pctx.beginPath();
                pctx.arc(p.x, p.y, r + (selectedElement === 'photo' ? 6 : 2), 0, Math.PI * 2);
                pctx.stroke();
            } else {
                pctx.strokeRect(p.x - r - (selectedElement === 'photo' ? 6 : 2), p.y - r - (selectedElement === 'photo' ? 6 : 2), (r * 2) + (selectedElement === 'photo' ? 12 : 4), (r * 2) + (selectedElement === 'photo' ? 12 : 4));
            }
            pctx.restore();

            // Photo label
            pctx.fillStyle = '#fff';
            pctx.font = 'bold 12px Inter';
            pctx.fillText('Photo', p.x + 8, p.y - 8);

            // Text elements overlay
            const textEls = ['name', 'roll'];
            textEls.forEach(el => {
                const ax = layout[el + 'X'] || defaultLayout[el + 'X'];
                const ay = layout[el + 'Y'] || defaultLayout[el + 'Y'];
                const pos = actualToPreview(ax, ay);
                const w = Math.max(80, Math.round((layout[el + 'MaxWidth'] || 200) * scale));
                const h = Math.round((layout[el + 'Line'] || 22) * 1.3);

                pctx.save();
                pctx.globalAlpha = 0.2;
                pctx.fillStyle = selectedElement === el ? '#667eea' : (el === 'name' ? '#10b981' : '#f59e0b');
                pctx.fillRect(pos.x, pos.y - h / 2, w, h);

                pctx.globalAlpha = 1;
                pctx.strokeStyle = selectedElement === el ? '#667eea' : 'rgba(0,0,0,0.2)';
                pctx.lineWidth = selectedElement === el ? 3 : 1;
                pctx.strokeRect(pos.x - (selectedElement === el ? 4 : 0), pos.y - h / 2 - (selectedElement === el ? 4 : 0), w + (selectedElement === el ? 8 : 0), h + (selectedElement === el ? 8 : 0));

                pctx.fillStyle = '#fff';
                pctx.font = 'bold 12px Inter';
                pctx.fillText(el.charAt(0).toUpperCase() + el.slice(1), pos.x + 6, pos.y - (h / 2) + 4);
                pctx.restore();
            });

            // Barcode overlay
            const bx = layout.barcodeX || defaultLayout.barcodeX;
            const by = layout.barcodeY || defaultLayout.barcodeY;
            const bw = layout.barcodeW || defaultLayout.barcodeW;
            const bh = layout.barcodeH || defaultLayout.barcodeH;
            const ppos = actualToPreview(bx, by);

            pctx.save();
            pctx.globalAlpha = 0.25;
            pctx.fillStyle = selectedElement === 'barcode' ? '#667eea' : '#374151';
            const pw = Math.round(bw * (preview.width / templateImage.width));
            const ph = Math.max(8, Math.round(bh * (preview.height / templateImage.height)));
            pctx.fillRect(ppos.x - Math.round(pw / 2), ppos.y - Math.round(ph / 2), pw, ph);

            pctx.globalAlpha = 1;
            pctx.strokeStyle = selectedElement === 'barcode' ? '#667eea' : 'rgba(0,0,0,0.2)';
            pctx.lineWidth = selectedElement === 'barcode' ? 3 : 1;
            pctx.strokeRect(ppos.x - Math.round(pw / 2) - (selectedElement === 'barcode' ? 4 : 0), ppos.y - Math.round(ph / 2) - (selectedElement === 'barcode' ? 4 : 0), pw + (selectedElement === 'barcode' ? 8 : 0), ph + (selectedElement === 'barcode' ? 8 : 0));

            pctx.fillStyle = '#fff';
            pctx.font = 'bold 12px Inter';
            pctx.fillText('Barcode', ppos.x - Math.round(pw / 2) + 6, ppos.y - Math.round(ph / 2) - 6);
            pctx.restore();
        }

        function toggleOverlayLabels() {
            showOverlays = !showOverlays;
            $('showOverlaysInput').checked = showOverlays;
            drawPreview();
        }

        function selectElement(el) {
            selectedElement = el;
            $('activeField').textContent = el.charAt(0).toUpperCase() + el.slice(1);

            document.querySelectorAll('.control-group').forEach(r => r.classList.remove('active-element'));
            const row = document.getElementById('row-' + el);
            if (row) row.classList.add('active-element');

            setActiveStyleInputs();
            drawPreview();
        }

        preview.addEventListener('click', function (e) {
            const rect = preview.getBoundingClientRect();
            const px = e.clientX - rect.left;
            const py = e.clientY - rect.top;

            if (placingElement) {
                const actual = previewToActual(px, py);
                placeAtActive(placingElement, actual.x, actual.y);
                const elementName = placingElement;
                placingElement = null;
                preview.style.cursor = 'default';
                drawPreview();
                livePreview();
                showNotification(`${elementName} positioned successfully!`);
            }
        });

        function enterPlaceMode(el) {
            placingElement = el;
            preview.style.cursor = 'crosshair';
            showNotification(`Click on the preview to position "${el}". Press Esc to cancel.`, 'warning');
        }

        document.addEventListener('keydown', function (e) {
            if (e.key === 'Escape' && placingElement) {
                placingElement = null;
                preview.style.cursor = 'default';
                showNotification('Placement cancelled');
            }

            if (!['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement.tagName)) {
                const step = e.shiftKey ? 10 : 1;
                let dx = 0, dy = 0;

                if (e.key === 'ArrowUp') { dy = -step; e.preventDefault(); }
                if (e.key === 'ArrowDown') { dy = step; e.preventDefault(); }
                if (e.key === 'ArrowLeft') { dx = -step; e.preventDefault(); }
                if (e.key === 'ArrowRight') { dx = step; e.preventDefault(); }

                if (dx || dy) nudgeElement(selectedElement, dx, dy);
            }
        });

        function placeAtActive(el, ax, ay) {
            if (el === 'photo') {
                layout.photoX = ax;
                layout.photoY = ay;
                $('photoX_input').value = layout.photoX;
                $('photoY_input').value = layout.photoY;
            } else if (el === 'roll') {
                layout.rollX = ax;
                layout.rollY = ay;
                $('rollX_input').value = layout.rollX;
                $('rollY_input').value = layout.rollY;
            } else if (el === 'barcode') {
                layout.barcodeX = ax;
                layout.barcodeY = ay;
                $('barcodeX_input').value = layout.barcodeX;
                $('barcodeY_input').value = layout.barcodeY;
            } else {
                layout[el + 'X'] = ax;
                layout[el + 'Y'] = ay;
                $(el + 'X_input').value = layout[el + 'X'];
                $(el + 'Y_input').value = layout[el + 'Y'];
            }
        }

        function nudgeElement(el, dx, dy) {
            if (el === 'photo') {
                layout.photoX = (layout.photoX || defaultLayout.photoX) + dx;
                layout.photoY = (layout.photoY || defaultLayout.photoY) + dy;
                $('photoX_input').value = layout.photoX;
                $('photoY_input').value = layout.photoY;
            } else if (el === 'roll') {
                layout.rollX = (layout.rollX || defaultLayout.rollX) + dx;
                layout.rollY = (layout.rollY || defaultLayout.rollY) + dy;
                $('rollX_input').value = layout.rollX;
                $('rollY_input').value = layout.rollY;
            } else if (el === 'barcode') {
                layout.barcodeX = (layout.barcodeX || defaultLayout.barcodeX) + dx;
                layout.barcodeY = (layout.barcodeY || defaultLayout.barcodeY) + dy;
                $('barcodeX_input').value = layout.barcodeX;
                $('barcodeY_input').value = layout.barcodeY;
            } else {
                layout[el + 'X'] = (layout[el + 'X'] || defaultLayout[el + 'X']) + dx;
                layout[el + 'Y'] = (layout[el + 'Y'] || defaultLayout[el + 'Y']) + dy;
                $(el + 'X_input').value = layout[el + 'X'];
                $(el + 'Y_input').value = layout[el + 'Y'];
            }
            drawPreview();
            livePreview();
        }

        function wirePositionInputs() {
            const inputs = document.querySelectorAll('.pos-input');
            inputs.forEach(inp => inp.addEventListener('input', function () {
                const id = this.id.split('_')[0];
                const axis = id.endsWith('X') ? 'X' : 'Y';
                const el = id.replace(/X$|Y$/, '');
                const val = parseInt(this.value) || 0;

                if (el === 'photo') {
                    if (axis === 'X') layout.photoX = val;
                    else layout.photoY = val;
                } else if (el === 'roll') {
                    if (axis === 'X') layout.rollX = val;
                    else layout.rollY = val;
                } else if (el === 'barcode') {
                    if (axis === 'X') layout.barcodeX = val;
                    else layout.barcodeY = val;
                } else {
                    layout[el + axis] = val;
                }
                drawPreview();
                livePreview();
            }));
        }

        function updatePhotoSizeFromSlider(v) {
            const val = parseInt(v) || 80;
            $('photoSize_input').value = val;
            $('photoSize').value = val;
            layout.photoSize = val;
            drawPreview();
            livePreview();
        }

        function snap(v) {
            if (!$('snapToggle').checked) return v;
            const g = parseInt($('gridSize').value) || 10;
            return Math.round(v / g) * g;
        }

        function snapAllToGrid() {
            ['photo', 'name', 'roll', 'barcode'].forEach(k => {
                if (k === 'photo') {
                    layout.photoX = snap(layout.photoX || defaultLayout.photoX);
                    layout.photoY = snap(layout.photoY || defaultLayout.photoY);
                    layout.photoSize = snap(layout.photoSize || defaultLayout.photoSize);
                } else {
                    layout[k + 'X'] = snap(layout[k + 'X'] || defaultLayout[k + 'X']);
                    layout[k + 'Y'] = snap(layout[k + 'Y'] || defaultLayout[k + 'Y']);
                }
            });
            populateLeftInputsFromLayout();
            drawPreview();
            livePreview();
            showNotification('All elements snapped to grid!');
        }

        function setActiveStyleInputs() {
            const el = selectedElement || 'photo';
            $('activeField').textContent = el.charAt(0).toUpperCase() + el.slice(1);

            document.querySelectorAll('.control-group').forEach(r => r.classList.remove('active-element'));
            const row = document.getElementById('row-' + el);
            if (row) row.classList.add('active-element');

            if (el === 'photo') {
                $('photoSize').value = layout.photoSize || defaultLayout.photoSize;
                $('photoShape').value = layout.photoShape || defaultLayout.photoShape;
                $('photoBorder').value = layout.photoBorder || 0;
                $('photoBorderColor').value = layout.photoBorderColor || '#ffffff';
                $('photoRadius').value = layout.photoRadius || defaultLayout.photoRadius;
            } else if (el === 'barcode') {
                $('barcodeW').value = layout.barcodeW || defaultLayout.barcodeW;
                $('barcodeH').value = layout.barcodeH || defaultLayout.barcodeH;
                $('barcodeFormat').value = layout.barcodeFormat || defaultLayout.barcodeFormat;
            } else {
                const prefix = (el === 'roll') ? 'roll' : el;
                $('fontFamily').value = layout[prefix + 'Family'] || defaultLayout[prefix + 'Family'] || 'Arial';
                $('fontSize').value = layout[prefix + 'Size'] || defaultLayout[prefix + 'Size'] || (prefix === 'name' ? 28 : 18);
                $('fontWeight').value = layout[prefix + 'Weight'] || defaultLayout[prefix + 'Weight'] || 400;
                $('fontStyle').value = layout[prefix + 'Style'] || defaultLayout[prefix + 'Style'] || 'normal';
                $('fontColor').value = layout[prefix + 'Color'] || defaultLayout[prefix + 'Color'] || '#000000';
                $('lineHeight').value = layout[prefix + 'Line'] || defaultLayout[prefix + 'Line'] || (parseInt($('fontSize').value) + 6);
                $('maxWidth').value = layout[prefix + 'MaxWidth'] || defaultLayout[prefix + 'MaxWidth'] || 300;
                $('textAlign').value = layout[prefix + 'Align'] || defaultLayout[prefix + 'Align'] || 'left';
                $('autoFit').value = layout[prefix + 'AutoFit'] ? '1' : '0';
                $('maxLines').value = layout[prefix + 'MaxLines'] || defaultLayout[prefix + 'MaxLines'] || 2;
            }
        }

        function applyStyleToActive() {
            const el = selectedElement || 'photo';
            if (el === 'photo') {
                layout.photoSize = parseInt($('photoSize').value) || layout.photoSize;
                layout.photoShape = $('photoShape').value;
                layout.photoBorder = parseInt($('photoBorder').value) || 0;
                layout.photoBorderColor = $('photoBorderColor').value || '#ffffff';
                layout.photoRadius = parseInt($('photoRadius').value) || defaultLayout.photoRadius;
            } else if (el === 'barcode') {
                layout.barcodeW = parseInt($('barcodeW').value) || layout.barcodeW;
                layout.barcodeH = parseInt($('barcodeH').value) || layout.barcodeH;
                layout.barcodeFormat = $('barcodeFormat').value || layout.barcodeFormat;
            } else {
                const prefix = (el === 'roll') ? 'roll' : el;
                layout[prefix + 'Family'] = $('fontFamily').value;
                layout[prefix + 'Size'] = parseInt($('fontSize').value) || (prefix === 'name' ? 28 : 18);
                layout[prefix + 'Weight'] = $('fontWeight').value;
                layout[prefix + 'Style'] = $('fontStyle').value;
                layout[prefix + 'Color'] = $('fontColor').value;
                layout[prefix + 'Line'] = parseInt($('lineHeight').value) || (layout[prefix + 'Size'] + 6);
                layout[prefix + 'MaxWidth'] = parseInt($('maxWidth').value) || 300;
                layout[prefix + 'Align'] = $('textAlign').value;
                layout[prefix + 'AutoFit'] = $('autoFit').value === '1';
                layout[prefix + 'MaxLines'] = parseInt($('maxLines').value) || 2;
            }
            drawPreview();
            livePreview();
        }

        function applyStyleToAll() {
            const family = $('fontFamily').value;
            const size = parseInt($('fontSize').value) || 18;
            const color = $('fontColor').value;

            ['name', 'roll'].forEach(k => {
                const prefix = (k === 'roll') ? 'roll' : k;
                layout[prefix + 'Family'] = family;
                layout[prefix + 'Size'] = size;
                layout[prefix + 'Weight'] = $('fontWeight').value;
                layout[prefix + 'Style'] = $('fontStyle').value;
                layout[prefix + 'Color'] = color;
                layout[prefix + 'Line'] = parseInt($('lineHeight').value) || 20;
                layout[prefix + 'MaxWidth'] = parseInt($('maxWidth').value) || 300;
                layout[prefix + 'Align'] = $('textAlign').value;
                layout[prefix + 'AutoFit'] = $('autoFit').value === '1';
                layout[prefix + 'MaxLines'] = parseInt($('maxLines').value) || 2;
            });
            drawPreview();
            livePreview();
            showNotification('Style applied to all text fields!');
        }

        // Text processing functions
        function autoFitFont(ctx, text, maxWidth, initialSize, family, weight, style, minSize = 8, maxLines = 3) {
            let size = initialSize;
            let lines = [];

            while (size >= minSize) {
                ctx.font = `${style} ${weight} ${size}px ${family}`;
                lines = breakTextToLines(ctx, text, maxWidth, maxLines);
                const maxLineWidth = lines.reduce((m, l) => Math.max(m, ctx.measureText(l).width), 0);
                if (maxLineWidth <= maxWidth) break;
                size -= 1;
            }
            return { size, lines };
        }

        function breakTextToLines(ctx, text, maxWidth, maxLines) {
            const words = String(text).split(' ');
            const result = [];
            let line = '';

            for (let i = 0; i < words.length; i++) {
                const test = (line ? line + ' ' : '') + words[i];
                if (ctx.measureText(test).width > maxWidth && line) {
                    result.push(line);
                    line = words[i];
                    if (result.length >= maxLines) break;
                } else {
                    line = test;
                }
            }

            if (result.length < maxLines && line) result.push(line);
            if (result.length > maxLines) result.length = maxLines;
            if (result.length === maxLines && ctx.measureText(result[result.length - 1]).width > maxWidth) {
                let s = result[result.length - 1];
                while (ctx.measureText(s + '...').width > maxWidth && s.length) s = s.slice(0, -1);
                result[result.length - 1] = s.trim() + '...';
            }
            return result;
        }

        function processCSV() {
            if (!csvRows.length) {
                showNotification('Please upload a CSV file first', 'error');
                return;
            }
            if (!templateImage) {
                showNotification('Please upload a template image first', 'error');
                return;
            }

            showNotification(`Generating ${csvRows.length} ID cards...`, 'warning');
            generateAll(csvRows);
        }

        function generateAll(rows) {
            const container = $('cardsContainer');
            container.innerHTML = '';

            rows.forEach((r, idx) => {
                const holder = document.createElement('div');
                holder.className = 'preview-card';

                const canvas = document.createElement('canvas');
                canvas.width = parseInt($('cardW').value) || layout.cardW;
                canvas.height = parseInt($('cardH').value) || layout.cardH;
                canvas.className = 'preview-canvas';
                const ctx = canvas.getContext('2d');

                if (templateImage) {
                    ctx.drawImage(templateImage, 0, 0, canvas.width, canvas.height);
                } else {
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }

                const photoKey = $('mapPhoto').value;
                const photoUrl = photoKey ? (r[photoKey] || r[photoKey.toLowerCase()] || '') : '';

                if (photoUrl) {
                    const img = new Image();
                    img.crossOrigin = "anonymous";
                    img.onload = () => {
                        drawPhotoOnCanvas(ctx, img, canvas);
                        drawAllTextAndBarcode(ctx, r, canvas);
                    };
                    img.onerror = () => {
                        drawAllTextAndBarcode(ctx, r, canvas);
                    };
                    img.src = photoUrl;
                } else {
                    drawAllTextAndBarcode(ctx, r, canvas);
                }

                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'preview-actions';

                const btn = document.createElement('button');
                btn.className = 'btn btn-primary';
                btn.innerHTML = '<span>‚¨áÔ∏è</span> Download';

                const nameForFile = sanitizeFilename((r[$('mapID').value] || `card-${idx + 1}`) + '_' + (r[$('mapName').value] || ''));
                btn.onclick = () => downloadCanvas(canvas, nameForFile);

                actionsDiv.appendChild(btn);
                holder.appendChild(canvas);
                holder.appendChild(actionsDiv);
                container.appendChild(holder);
            });

            showNotification(`Generated ${rows.length} ID cards successfully!`);
        }

        // Canvas drawing functions
        function drawPhotoOnCanvas(ctx, img, canvasEl) {
            ctx.save();
            const x = layout.photoX || defaultLayout.photoX;
            const y = layout.photoY || defaultLayout.photoY;
            const size = layout.photoSize || defaultLayout.photoSize;

            if (layout.photoShape === 'circle') {
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.closePath();
                ctx.clip();
                ctx.drawImage(img, x - size, y - size, size * 2, size * 2);
                ctx.restore();

                if (layout.photoBorder > 0) {
                    ctx.beginPath();
                    ctx.arc(x, y, size + layout.photoBorder / 2, 0, Math.PI * 2);
                    ctx.lineWidth = layout.photoBorder;
                    ctx.strokeStyle = layout.photoBorderColor || '#ffffff';
                    ctx.stroke();
                }
            } else if (layout.photoShape === 'rectangle') {
                const w = size, h = size;
                ctx.drawImage(img, x - w / 2, y - h / 2, w, h);

                if (layout.photoBorder > 0) {
                    ctx.lineWidth = layout.photoBorder;
                    ctx.strokeStyle = layout.photoBorderColor || '#ffffff';
                    ctx.strokeRect(x - w / 2, y - h / 2, w, h);
                }
            } else {
                const w = size, h = size, r = layout.photoRadius || 12;
                roundRectClip(ctx, x - w / 2, y - h / 2, w, h, r);
                ctx.drawImage(img, x - w / 2, y - h / 2, w, h);
                ctx.restore();

                if (layout.photoBorder > 0) {
                    roundRectStroke(ctx, x - w / 2, y - h / 2, w, h, r, layout.photoBorder, layout.photoBorderColor || '#ffffff');
                }
            }
        }

        function roundRectClip(ctx, x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
            ctx.clip();
        }

        function roundRectStroke(ctx, x, y, w, h, r, border, color) {
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
            ctx.lineWidth = border;
            ctx.strokeStyle = color;
            ctx.stroke();
            ctx.restore();
        }

        function drawAllTextAndBarcode(ctx, row, canvasEl) {
            drawAllTextOnCanvas(ctx, row);
            drawBarcodeOnCanvas(ctx, row);
        }

        function drawAllTextOnCanvas(ctx, row) {
            const read = k => {
                const map = { Name: 'mapName', ID: 'mapID' };
                const sel = $(map[k]).value;
                return sel ? (row[sel] || row[sel.toLowerCase()] || '') : '';
            };

            const fieldSpecs = [
                { key: 'name', label: read('Name') || '', prefix: 'name' },
                { key: 'roll', label: read('ID') || '', prefix: 'roll' }
            ];

            fieldSpecs.forEach(f => {
                if (!f.label) return;

                const prefix = f.prefix;
                const x = layout[prefix + 'X'] || defaultLayout[prefix + 'X'];
                const y = layout[prefix + 'Y'] || defaultLayout[prefix + 'Y'];
                const family = layout[prefix + 'Family'] || defaultLayout[prefix + 'Family'] || 'Arial';
                const initSize = layout[prefix + 'Size'] || defaultLayout[prefix + 'Size'] || 18;
                const weight = layout[prefix + 'Weight'] || defaultLayout[prefix + 'Weight'] || 400;
                const style = layout[prefix + 'Style'] || 'normal';
                const color = layout[prefix + 'Color'] || defaultLayout[prefix + 'Color'] || '#000';
                const line = layout[prefix + 'Line'] || defaultLayout[prefix + 'Line'] || (initSize + 6);
                const maxWidth = layout[prefix + 'MaxWidth'] || defaultLayout[prefix + 'MaxWidth'];
                const align = layout[prefix + 'Align'] || defaultLayout[prefix + 'Align'] || 'left';
                const autoFit = layout[prefix + 'AutoFit'] === undefined ? true : !!layout[prefix + 'AutoFit'];
                const maxLines = layout[prefix + 'MaxLines'] || defaultLayout[prefix + 'MaxLines'] || 3;

                ctx.fillStyle = color;

                if (maxWidth && autoFit) {
                    const { size, lines } = autoFitFont(ctx, f.label, maxWidth, initSize, family, weight, style, 8, maxLines);
                    ctx.font = `${style} ${weight} ${size}px ${family}`;
                    ctx.textBaseline = 'top';

                    let yy = y;
                    lines.forEach(lineText => {
                        drawAlignedText(ctx, lineText, x, yy, align);
                        yy += (layout[prefix + 'Line'] || line);
                    });
                } else {
                    ctx.font = `${style} ${weight} ${initSize}px ${family}`;
                    ctx.textBaseline = 'top';
                    const lines = breakTextToLines(ctx, f.label, maxWidth || 1000, maxLines);

                    let yy = y;
                    lines.forEach(lineText => {
                        drawAlignedText(ctx, lineText, x, yy, align);
                        yy += (layout[prefix + 'Line'] || line);
                    });
                }
            });
        }

        function drawAlignedText(ctx, text, x, y, align = 'left') {
            const metrics = ctx.measureText(text);
            const w = metrics.width;

            if (align === 'center') {
                ctx.fillText(text, x - w / 2, y);
            } else if (align === 'right') {
                ctx.fillText(text, x - w, y);
            } else {
                ctx.fillText(text, x, y);
            }
        }

        function drawBarcodeOnCanvas(ctx, row) {
            const barcodeMap = $('mapBarcode') ? ($('mapBarcode').value || $('mapID').value) : $('mapID').value;
            const idValue = barcodeMap ? (row[barcodeMap] || row[barcodeMap.toLowerCase()] || '') : '';
            if (!idValue) return;

            const bw = layout.barcodeW || defaultLayout.barcodeW;
            const bh = layout.barcodeH || defaultLayout.barcodeH;
            const bx = layout.barcodeX || defaultLayout.barcodeX;
            const by = layout.barcodeY || defaultLayout.barcodeY;
            const format = layout.barcodeFormat || defaultLayout.barcodeFormat;

            try {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = bw;
                tempCanvas.height = bh;

                JsBarcode(tempCanvas, String(idValue), {
                    format: format,
                    displayValue: false,
                    height: bh,
                    width: 1,
                    margin: 0
                });

                const dx = Math.round(bx - bw / 2);
                const dy = Math.round(by - bh / 2);
                ctx.drawImage(tempCanvas, dx, dy, bw, bh);
            } catch (err) {
                console.warn('Barcode render failed', err);
            }
        }

        function downloadCanvas(canvas, name) {
            canvas.toBlob(blob => {
                saveAs(blob, `${name}.png`);
                showNotification(`Downloaded ${name}.png`);
            });
        }

        function sanitizeFilename(s) {
            try {
                return s.toString().trim().replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_\-\.]/g, '');
            } catch (e) {
                return 'card';
            }
        }

        // Enhanced ZIP download functionality with progress bar
        async function downloadAllZip() {
            if (!csvRows.length) {
                showNotification('Please upload a CSV file first', 'error');
                return;
            }
            if (!templateImage) {
                showNotification('Please upload a template image first', 'error');
                return;
            }

            const modal = showProgressModal();
            const total = csvRows.length;
            let failed = 0;

            try {
                updateProgress(0, total, 'Initializing...');

                const zip = new JSZip();
                const folder = zip.folder('idcards') || zip;

                for (let i = 0; i < total; i++) {
                    const row = csvRows[i];
                    updateProgress(i + 1, total, `Processing card ${i + 1} of ${total}...`);

                    try {
                        const blob = await renderCardBlobForRow(row, i);
                        const idVal = (row[$('mapID').value] || `card-${i + 1}`).toString();
                        const nameVal = (row[$('mapName').value] || '').toString();
                        const filename = sanitizeFilename(idVal + '_' + nameVal) || `card-${i + 1}`;
                        folder.file(`${filename}.png`, blob);

                        // Small delay to allow UI updates
                        if (i % 10 === 0) {
                            await new Promise(resolve => setTimeout(resolve, 10));
                        }
                    } catch (e) {
                        failed++;
                        console.warn('Failed to render card:', e);
                    }
                }

                updateProgress(total, total, 'Creating ZIP file...');
                const content = await zip.generateAsync({
                    type: 'blob',
                    compression: 'DEFLATE',
                    compressionOptions: { level: 6 }
                });

                hideProgressModal();
                saveAs(content, 'idcards.zip');

                if (failed > 0) {
                    showNotification(`Generated ${total - failed} cards. ${failed} cards failed.`, 'warning');
                } else {
                    showNotification(`Successfully created ZIP with ${total} cards!`);
                }
            } catch (error) {
                hideProgressModal();
                console.error('ZIP creation failed:', error);
                showNotification('Failed to create ZIP file', 'error');
            }
        }

        async function renderCardBlobForRow(row, index) {
            const cw = parseInt($('cardW').value) || layout.cardW;
            const ch = parseInt($('cardH').value) || layout.cardH;
            const canvas = document.createElement('canvas');
            canvas.width = cw;
            canvas.height = ch;
            const ctx = canvas.getContext('2d');

            if (templateImage) {
                ctx.drawImage(templateImage, 0, 0, canvas.width, canvas.height);
            } else {
                ctx.fillStyle = '#fff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            const photoKey = $('mapPhoto').value;
            const photoUrl = photoKey ? (row[photoKey] || row[photoKey.toLowerCase()] || '') : '';

            if (photoUrl) {
                try {
                    const img = await loadImagePromise(photoUrl);
                    drawPhotoOnCanvas(ctx, img, canvas);
                } catch (err) {
                    console.warn('Photo loading failed:', err);
                }
            }

            drawAllTextOnCanvas(ctx, row);
            drawBarcodeOnCanvas(ctx, row);

            return new Promise(resolve => canvas.toBlob(blob => resolve(blob), 'image/png'));
        }

        function loadImagePromise(url) {
            return new Promise((resolve, reject) => {
                if (!url) {
                    reject('no-url');
                    return;
                }
                const img = new Image();
                img.crossOrigin = "anonymous";
                img.onload = () => resolve(img);
                img.onerror = () => reject('img-error');
                img.src = url;
            });
        }

        // Layout management functions
        function exportLayout() {
            const out = {
                layout,
                maps: {
                    photo: $('mapPhoto') ? $('mapPhoto').value : '',
                    name: $('mapName') ? $('mapName').value : '',
                    id: $('mapID') ? $('mapID').value : '',
                    barcode: $('mapBarcode') ? $('mapBarcode').value : ''
                }
            };

            const blob = new Blob([JSON.stringify(out, null, 2)], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'idcard-layout.json';
            a.click();

            showNotification('Layout exported successfully!');
        }

        function saveLayoutLocal() {
            const layoutData = {
                layout,
                maps: {
                    photo: $('mapPhoto').value,
                    name: $('mapName').value,
                    id: $('mapID').value,
                    barcode: $('mapBarcode') ? $('mapBarcode').value : ''
                }
            };
            localStorage.setItem('idcard_layout', JSON.stringify(layoutData));
            showNotification('Layout saved to browser storage!');
        }

        function livePreview() {
            const first = csvRows.length ? csvRows[0] : {
                name: 'Sample Name',
                id: '000',
                profile: '',
                dob: '2000-01-01',
                bloodgroup: 'O+',
                contactno: '0000000000',
                address: 'Sample address'
            };
            renderSingleOnPreview(first, true);
        }

        function renderSingleOnPreview(row, isLive = false) {
            const cw = parseInt($('cardW').value) || layout.cardW;
            const ch = parseInt($('cardH').value) || layout.cardH;
            const canvas = document.createElement('canvas');
            canvas.width = cw;
            canvas.height = ch;
            canvas.className = 'preview-canvas';
            const ctx = canvas.getContext('2d');

            if (templateImage) {
                ctx.drawImage(templateImage, 0, 0, canvas.width, canvas.height);
            } else {
                ctx.fillStyle = '#fff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            const photoKey = $('mapPhoto').value;
            const photoUrl = photoKey ? (row[photoKey] || row[photoKey.toLowerCase()] || '') : '';

            if (photoUrl) {
                const img = new Image();
                img.crossOrigin = "anonymous";
                img.onload = () => {
                    drawPhotoOnCanvas(ctx, img, canvas);
                    drawAllTextOnCanvas(ctx, row);
                    drawBarcodeOnCanvas(ctx, row);
                    appendPreview(canvas, isLive);
                };
                img.onerror = () => {
                    drawAllTextOnCanvas(ctx, row);
                    drawBarcodeOnCanvas(ctx, row);
                    appendPreview(canvas, isLive);
                };
                img.src = photoUrl;
            } else {
                drawAllTextOnCanvas(ctx, row);
                drawBarcodeOnCanvas(ctx, row);
                appendPreview(canvas, isLive);
            }
        }

        function appendPreview(canvas, isLive) {
            const container = $('cardsContainer');

            if (isLive) {
                const prev = document.getElementById('__live_preview');
                if (prev) prev.remove();

                const holder = document.createElement('div');
                holder.className = 'preview-card';
                holder.id = '__live_preview';
                holder.style.border = '3px solid #667eea';

                const el = document.createElement('canvas');
                el.width = canvas.width;
                el.height = canvas.height;
                el.className = 'preview-canvas';
                el.getContext('2d').drawImage(canvas, 0, 0);

                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'preview-actions';
                actionsDiv.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 1rem;">
                        <span style="font-size: 0.8rem; color: #667eea; font-weight: 700; text-transform: uppercase; letter-spacing: 0.05em;">LIVE PREVIEW</span>
                        <span style="font-size: 0.8rem; color: var(--gray-500);">Updates automatically</span>
                    </div>
                `;

                const btn = document.createElement('button');
                btn.className = 'btn btn-secondary';
                btn.innerHTML = '<span>‚¨áÔ∏è</span> Download Sample';
                btn.onclick = () => downloadCanvas(el, 'sample');

                actionsDiv.appendChild(btn);
                holder.appendChild(el);
                holder.appendChild(actionsDiv);
                container.prepend(holder);
            }
        }

        function populateLeftInputsFromLayout() {
            $('photoX_input').value = layout.photoX || defaultLayout.photoX;
            $('photoY_input').value = layout.photoY || defaultLayout.photoY;
            $('nameX_input').value = layout.nameX || defaultLayout.nameX;
            $('nameY_input').value = layout.nameY || defaultLayout.nameY;
            $('rollX_input').value = layout.rollX || defaultLayout.rollX;
            $('rollY_input').value = layout.rollY || defaultLayout.rollY;
            $('barcodeX_input').value = layout.barcodeX || defaultLayout.barcodeX;
            $('barcodeY_input').value = layout.barcodeY || defaultLayout.barcodeY;
            $('photoSize_input').value = layout.photoSize || defaultLayout.photoSize;
            $('photoSize').value = layout.photoSize || defaultLayout.photoSize;
        }

        function init() {
            wirePositionInputs();

            // Element selection handlers
            document.querySelectorAll('.control-group').forEach(row => {
                row.addEventListener('click', () => {
                    const el = row.dataset.el;
                    if (el) selectElement(el);
                });
            });

            // Form control event listeners for immediate feedback
            ['fontFamily', 'fontSize', 'fontWeight', 'fontStyle', 'fontColor', 'lineHeight', 'maxWidth', 'textAlign', 'autoFit', 'maxLines'].forEach(id => {
                const el = $(id);
                if (el) {
                    el.addEventListener('input', applyStyleToActive);
                    el.addEventListener('change', applyStyleToActive);
                }
            });

            // Photo size sync
            $('photoSize').addEventListener('input', () => {
                $('photoSize_input').value = $('photoSize').value;
                layout.photoSize = parseInt($('photoSize').value) || layout.photoSize;
                drawPreview();
                livePreview();
            });

            // Photo controls
            ['photoShape', 'photoBorder', 'photoBorderColor', 'photoRadius'].forEach(id => {
                const el = $(id);
                if (el) el.addEventListener('input', applyStyleToActive);
            });

            // CSV mapping listeners
            ['mapPhoto', 'mapName', 'mapID', 'mapBarcode'].forEach(id => {
                const el = $(id);
                if (el) {
                    el.addEventListener('change', () => {
                        updateMappingStatus();
                        livePreview();
                    });
                }
            });

            // Barcode controls
            ['barcodeW', 'barcodeH', 'barcodeFormat'].forEach(id => {
                const el = $(id);
                if (el) {
                    el.addEventListener('input', () => {
                        layout.barcodeW = parseInt($('barcodeW').value) || layout.barcodeW;
                        layout.barcodeH = parseInt($('barcodeH').value) || layout.barcodeH;
                        layout.barcodeFormat = $('barcodeFormat').value || layout.barcodeFormat;
                        drawPreview();
                        livePreview();
                    });
                }
            });

            // Card size controls
            ['cardW', 'cardH'].forEach(id => {
                const el = $(id);
                if (el) {
                    el.addEventListener('input', () => {
                        layout.cardW = parseInt($('cardW').value) || layout.cardW;
                        layout.cardH = parseInt($('cardH').value) || layout.cardH;
                        drawPreview();
                        livePreview();
                    });
                }
            });

            // Grid and overlay controls
            $('gridSize').addEventListener('input', drawPreview);
            $('snapToggle').addEventListener('change', drawPreview);

            // Initialize UI state
            setTimeout(() => {
                selectElement('photo');
                setActiveStyleInputs();
                drawPreview();
                livePreview();

                // Try to load saved layout
                const saved = localStorage.getItem('idcard_layout');
                if (saved) {
                    try {
                        const obj = JSON.parse(saved);
                        if (obj.layout) {
                            layout = Object.assign({}, layout, obj.layout);
                            populateLeftInputsFromLayout();
                            setActiveStyleInputs();
                            drawPreview();
                            livePreview();
                            showNotification('Loaded previously saved layout');
                        }
                    } catch (e) {
                        console.warn('Failed to load saved layout:', e);
                    }
                }
            }, 200);
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', init);

        // Add keyboard shortcuts
        document.addEventListener('keydown', function (e) {
            if (e.ctrlKey || e.metaKey) {
                switch (e.key) {
                    case 's':
                        e.preventDefault();
                        saveLayoutLocal();
                        break;
                    case 'g':
                        e.preventDefault();
                        if (csvRows.length && templateImage) {
                            processCSV();
                        }
                        break;
                }
            }
        });

        // Auto-save functionality
        let autoSaveTimeout;
        function scheduleAutoSave() {
            clearTimeout(autoSaveTimeout);
            autoSaveTimeout = setTimeout(() => {
                saveLayoutLocal();
            }, 5000);
        }

        // Add drag and drop support
        const container = document.querySelector('.container');

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            container.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        container.addEventListener('dragover', function (e) {
            container.style.background = 'linear-gradient(135deg, #f0f4ff 0%, #e0e7ff 100%)';
        });

        container.addEventListener('dragleave', function (e) {
            container.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
        });

        container.addEventListener('drop', function (e) {
            container.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';

            const files = Array.from(e.dataTransfer.files);

            files.forEach(file => {
                if (file.type.startsWith('image/')) {
                    updateFileNameDisplay('template', file.name);
                    // Handle template image
                    const reader = new FileReader();
                    reader.onload = function (e) {
                        templateImage = new Image();
                        templateImage.onload = function () {
                            const maxW = 420, maxH = 600;
                            const scale = Math.min(maxW / templateImage.width, maxH / templateImage.height, 1);
                            preview.width = Math.round(templateImage.width * scale);
                            preview.height = Math.round(templateImage.height * scale);
                            $('cardW').value = templateImage.width;
                            $('cardH').value = templateImage.height;
                            drawPreview();
                            populateLeftInputsFromLayout();
                            showNotification('Template image loaded via drag & drop!');
                        };
                        templateImage.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                } else if (file.name.endsWith('.csv')) {
                    updateFileNameDisplay('csv', file.name);
                    // Handle CSV file
                    Papa.parse(file, {
                        header: true,
                        skipEmptyLines: true,
                        complete: function (results) {
                            csvRows = results.data;
                            csvHeaders = results.meta.fields || Object.keys(csvRows[0] || {});
                            populateMappingDropdowns();
                            livePreview();
                            showNotification(`CSV loaded via drag & drop with ${csvRows.length} records!`);
                        }
                    });
                } else if (file.name.endsWith('.json')) {
                    updateFileNameDisplay('layout', file.name);
                    // Handle layout file
                    const reader = new FileReader();
                    reader.onload = function (e) {
                        try {
                            const obj = JSON.parse(e.target.result);
                            if (obj.layout) {
                                layout = Object.assign({}, layout, obj.layout);
                                if (obj.maps) {
                                    if ($('mapPhoto')) $('mapPhoto').value = obj.maps.photo || '';
                                    if ($('mapName')) $('mapName').value = obj.maps.name || '';
                                    if ($('mapID')) $('mapID').value = obj.maps.id || '';
                                    if ($('mapBarcode')) $('mapBarcode').value = obj.maps.barcode || '';
                                }
                                populateLeftInputsFromLayout();
                                updateMappingStatus();
                                drawPreview();
                                livePreview();
                                showNotification('Layout loaded via drag & drop!');
                            }
                        } catch (err) {
                            showNotification('Invalid layout file', 'error');
                        }
                    };
                    reader.readAsText(file);
                }
            });
        });
    </script>
</body>

</html>