<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>ID Card Generator â€” Photo + Name + ID + Barcode</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&family=Roboto:wght@400;700&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --bg: #f5f6f8;
            --muted: #666;
            --accent: #007bff;
        }

        body {
            font-family: Inter, Roboto, Arial, sans-serif;
            margin: 0;
            background: var(--bg);
            padding: 18px;
        }

        .wrap {
            max-width: 1300px;
            margin: 0 auto;
            background: #fff;
            border-radius: 10px;
            padding: 18px;
            box-shadow: 0 6px 24px rgba(0, 0, 0, .06);
        }

        h1 {
            margin: 0 0 8px;
            font-size: 20px;
        }

        .row {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .col {
            background: #fafafa;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #eee;
        }

        .left {
            flex: 0 0 420px;
        }

        .right {
            flex: 1;
            min-width: 320px;
        }

        label {
            display: block;
            font-size: 12px;
            color: var(--muted);
            margin-bottom: 6px;
        }

        input[type=file],
        select,
        input[type=number],
        input[type=color],
        button,
        input[type=text] {
            width: 100%;
            padding: 8px;
            border-radius: 6px;
            border: 1px solid #ddd;
        }

        button {
            cursor: pointer;
        }

        .btn-primary {
            background: var(--accent);
            color: #fff;
            border: none;
            padding: 10px 12px;
            border-radius: 6px;
        }

        .small-btn {
            padding: 8px 10px;
            border-radius: 6px;
            border: 1px solid #ddd;
            background: #f8f9fa;
            cursor: pointer;
        }

        .small {
            font-size: 12px;
            color: var(--muted);
        }

        canvas {
            background: #fff;
            border-radius: 6px;
            border: 1px solid #ddd;
            display: block;
            max-width: 100%;
        }

        .element-row {
            padding: 8px;
            border-radius: 6px;
            background: #fff;
            border: 1px solid #eee;
            display: flex;
            gap: 8px;
            align-items: center;
            cursor: pointer;
        }

        .element-row.selected {
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.12);
            border-color: var(--accent);
        }

        .mapping {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .section-title {
            font-weight: 700;
            margin: 6px 0;
            font-size: 14px;
        }

        .divider {
            height: 1px;
            background: #eee;
            margin: 12px 0;
        }

        .cards {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
            gap: 12px;
            margin-top: 12px;
        }

        .card-preview {
            border-radius: 6px;
            overflow: hidden;
            background: #fff;
            padding: 10px;
            border: 1px solid #eee;
            text-align: center;
        }

        .muted {
            color: var(--muted);
            font-size: 12px;
        }

        .badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 6px;
            background: #f1f1f1;
            font-size: 12px;
        }

        .active-label {
            font-weight: 700;
            color: var(--accent);
            margin-left: 8px;
        }
    </style>
</head>

<body>
    <div class="wrap">
        <h1>ID Card Generator â€” Photo + Name + ID + Barcode</h1>
        <p class="small">Upload template + CSV, map columns and generate PNG or ZIP. Barcode can be generated from any
            CSV
            field (select via Barcode source). Use Import/Export to save or load layout JSON.</p>

        <div class="top-controls" style="display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-bottom:12px;">
            <div style="width:260px"><label>Template image (jpg/png)</label><input id="templateFile" type="file"
                    accept="image/*"></div>
            <div style="width:320px"><label>CSV file</label><input id="csvFile" type="file" accept=".csv"></div>

            <div style="display:flex;align-items:center;gap:8px">
                <button class="btn-primary" onclick="processCSV()">Generate Cards</button>
                <button class="small-btn" onclick="exportLayout()">Export Layout</button>
                <button class="small-btn" onclick="saveLayoutLocal()">Save Layout</button>
                <button class="small-btn" onclick="downloadAllZip()">Download All (ZIP)</button>
                <!-- Import control -->
                <label style="margin-left:8px;display:inline-block">
                    <input id="importLayout" type="file" accept=".json" style="display:none"
                        onchange="importLayoutFile(event)">
                    <button type="button" class="small-btn"
                        onclick="document.getElementById('importLayout').click()">Import Layout (JSON)</button>
                </label>
            </div>

            <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
                <label class="small">Grid</label><input id="gridSize" type="number" value="10" style="width:80px">
                <label class="small">Snap</label><input id="snapToggle" type="checkbox" checked>
                <label class="small">Overlays</label><input id="showOverlaysInput" type="checkbox" checked
                    onchange="toggleOverlayLabels()" />
            </div>
        </div>

        <div class="row">
            <div class="col left">
                <div class="section-title">Template preview & positioning</div>
                <div style="display:flex;gap:10px;">
                    <div style="flex:0 0 420px">
                        <div style="position:relative"><canvas id="preview" width="420" height="600"
                                style="border-radius:6px;"></canvas></div>
                        <div style="margin-top:8px; display:flex; gap:8px; align-items:center;"><button
                                class="small-btn" onclick="toggleOverlayLabels()">Toggle Overlays</button><button
                                class="small-btn" onclick="snapAllToGrid()">Snap Now</button>
                            <div style="margin-left:auto;" class="muted">Click an element's <strong>Place</strong> to
                                position it.</div>
                        </div>
                    </div>

                    <div style="flex:1;min-width:220px">
                        <div class="section-title">Elements</div>
                        <div class="small">Click any row to select it. Use <strong>Place</strong> to position on the
                            preview.</div>

                        <div id="elementList" style="margin-top:10px; display:flex;flex-direction:column; gap:8px;">
                            <div id="row-photo" class="element-row" data-el="photo">
                                <div style="width:32px;font-size:14px">ðŸ“·</div>
                                <div style="flex:1">
                                    <div style="font-weight:600">Photo <span id="label-photo" class="badge"></span>
                                    </div>
                                    <div class="muted">X <input class="pos-input" id="photoX_input" type="number"
                                            style="width:90px"> Y
                                        <input class="pos-input" id="photoY_input" type="number" style="width:90px">
                                    </div>
                                </div>
                                <div style="display:flex;flex-direction:column;gap:6px;">
                                    <button class="small-btn" onclick="enterPlaceMode('photo');">Place</button>
                                    <button class="small-btn" onclick="nudgeElement('photo',0,-1);">â–²</button>
                                    <button class="small-btn" onclick="nudgeElement('photo',0,1);">â–¼</button>
                                </div>
                            </div>

                            <div id="row-name" class="element-row" data-el="name">
                                <div style="width:32px;font-size:14px">ðŸ‘¤</div>
                                <div style="flex:1">
                                    <div style="font-weight:600">Name <span id="label-name" class="badge"></span></div>
                                    <div class="muted">X <input class="pos-input" id="nameX_input" type="number"
                                            style="width:90px"> Y
                                        <input class="pos-input" id="nameY_input" type="number" style="width:90px">
                                    </div>
                                </div>
                                <div style="display:flex;flex-direction:column;gap:6px;">
                                    <button class="small-btn" onclick="enterPlaceMode('name');">Place</button>
                                    <button class="small-btn" onclick="nudgeElement('name',0,-1);">â–²</button>
                                    <button class="small-btn" onclick="nudgeElement('name',0,1);">â–¼</button>
                                </div>
                            </div>

                            <div id="row-roll" class="element-row" data-el="roll">
                                <div style="width:32px;font-size:14px">ðŸ†”</div>
                                <div style="flex:1">
                                    <div style="font-weight:600">Roll / ID <span id="label-roll" class="badge"></span>
                                    </div>
                                    <div class="muted">X <input class="pos-input" id="rollX_input" type="number"
                                            style="width:90px"> Y
                                        <input class="pos-input" id="rollY_input" type="number" style="width:90px">
                                    </div>
                                </div>
                                <div style="display:flex;flex-direction:column;gap:6px;">
                                    <button class="small-btn" onclick="enterPlaceMode('roll');">Place</button>
                                    <button class="small-btn" onclick="nudgeElement('roll',0,-1);">â–²</button>
                                    <button class="small-btn" onclick="nudgeElement('roll',0,1);">â–¼</button>
                                </div>
                            </div>

                            <div id="row-barcode" class="element-row" data-el="barcode">
                                <div style="width:32px;font-size:14px">ðŸ”¢</div>
                                <div style="flex:1">
                                    <div style="font-weight:600">Barcode <span id="label-barcode" class="badge"></span>
                                    </div>
                                    <div class="muted">X <input class="pos-input" id="barcodeX_input" type="number"
                                            style="width:90px"> Y
                                        <input class="pos-input" id="barcodeY_input" type="number" style="width:90px">
                                    </div>
                                </div>
                                <div style="display:flex;flex-direction:column;gap:6px;">
                                    <button class="small-btn" onclick="enterPlaceMode('barcode');">Place</button>
                                    <button class="small-btn" onclick="nudgeElement('barcode',0,-1);">â–²</button>
                                    <button class="small-btn" onclick="nudgeElement('barcode',0,1);">â–¼</button>
                                </div>
                            </div>
                        </div>

                        <div style="margin-top:10px;"> <label class="small">Photo size (px)</label> <input
                                id="photoSize_input" type="range" min="16" max="400" value="80"
                                oninput="updatePhotoSizeFromSlider(this.value)"> </div>
                    </div>
                </div>
            </div>

            <div class="col right">
                <div style="display:flex;align-items:center;gap:8px">
                    <div class="section-title">Field styling & size</div>
                    <div class="muted">Active: <span id="activeField" class="active-label">Photo</span></div>
                </div>

                <div style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px">
                    <div><label>Font family</label><select id="fontFamily">
                            <option value="Arial">Arial</option>
                            <option value="Roboto">Roboto</option>
                            <option value="Inter">Inter</option>
                            <option value="Times New Roman">Times New Roman</option>
                            <option value="Georgia">Georgia</option>
                        </select></div>
                    <div><label>Font size (px)</label><input id="fontSize" type="number" value="20"></div>
                    <div><label>Bold</label><select id="fontWeight">
                            <option value="400">Normal</option>
                            <option value="700">Bold</option>
                        </select></div>
                    <div><label>Italic</label><select id="fontStyle">
                            <option value="normal">Normal</option>
                            <option value="italic">Italic</option>
                        </select></div>
                    <div><label>Color</label><input id="fontColor" type="color" value="#000000"></div>
                    <div><label>Line height (px)</label><input id="lineHeight" type="number" value="22"></div>
                    <div><label>Max width (px) â€” wrap</label><input id="maxWidth" type="number" value="300"></div>
                    <div><label>Text align</label><select id="textAlign">
                            <option value="left">Left</option>
                            <option value="center">Center</option>
                            <option value="right">Right</option>
                        </select></div>
                    <div><label>Auto-fit font (shrink to fit)</label><select id="autoFit">
                            <option value="1">Enabled</option>
                            <option value="0">Disabled</option>
                        </select></div>
                    <div><label>Max lines (for wrap)</label><input id="maxLines" type="number" value="2" min="1"
                            max="10"></div>
                </div>

                <div style="margin-top:12px" class="divider"></div>

                <div class="section-title">Photo controls</div>
                <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px">
                    <div><label>Photo size (px)</label><input id="photoSize" type="number" value="80"></div>
                    <div><label>Shape</label><select id="photoShape">
                            <option value="circle">Circle</option>
                            <option value="rectangle">Rect</option>
                            <option value="rounded">Rounded</option>
                        </select></div>
                    <div><label>Border (px)</label><input id="photoBorder" type="number" value="0"></div>
                </div>

                <div style="margin-top:12px" class="divider"></div>

                <div class="section-title">Barcode controls</div>
                <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;align-items:center">
                    <div><label>Barcode source</label><select id="mapBarcode">
                            <option value="">â€” none â€”</option>
                        </select></div>
                    <div><label>Barcode width (px)</label><input id="barcodeW" type="number" value="300"></div>
                    <div><label>Barcode height (px)</label><input id="barcodeH" type="number" value="60"></div>
                    <div style="grid-column:span 2"><label>Barcode format</label><select id="barcodeFormat">
                            <option value="CODE128">CODE128</option>
                            <option value="EAN13">EAN13</option>
                            <option value="EAN8">EAN8</option>
                            <option value="UPC">UPC</option>
                        </select></div>
                </div>

                <div style="margin-top:12px" class="divider"></div>

                <div class="section-title">Layout & card size</div>
                <div style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px">
                    <div><label>Card width (px)</label><input id="cardW" type="number" value="800"></div>
                    <div><label>Card height (px)</label><input id="cardH" type="number" value="1200"></div>
                </div>

                <div style="margin-top:12px" class="divider"></div>

                <div style="display:flex;gap:8px;align-items:center"><button class="btn-primary"
                        onclick="applyStyleToActive()">Apply to Active</button><button class="small-btn"
                        onclick="applyStyleToAll()">Apply to All Text Fields</button>
                    <div style="margin-left:auto" class="small">Changes update preview instantly.</div>
                </div>

                <div class="divider"></div>

                <div class="section-title">Map CSV columns</div>
                <div class="small">After uploading CSV the dropdowns list headers. Map them to fields.</div>
                <div style="margin-top:8px">
                    <div class="mapping"><label class="small" style="width:80px">Photo</label><select
                            id="mapPhoto"></select></div>
                    <div class="mapping"><label class="small" style="width:80px">Name</label><select
                            id="mapName"></select></div>
                    <div class="mapping"><label class="small" style="width:80px">ID/Roll</label><select
                            id="mapID"></select></div>
                </div>

                <div class="divider"></div>

                <div class="section-title">Generated previews</div>
                <div class="cards" id="cardsContainer"></div>
            </div>
        </div>
    </div>

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.0/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <!-- JsBarcode for barcode rendering -->
    <script src="https://cdn.jsdelivr.net/npm/jsbarcode@3.11.5/dist/JsBarcode.all.min.js"></script>

    <script>
        let templateImage = null;
        let csvHeaders = [];
        let csvRows = [];
        let selectedElement = 'photo';
        let placingElement = null;
        let showOverlays = true;

        const defaultLayout = {
            cardW: 800, cardH: 1200,
            photoX: 400, photoY: 180, photoSize: 80, photoShape: 'circle', photoBorder: 0, photoBorderColor: '#ffffff', photoRadius: 12,
            nameX: 80, nameY: 400, nameSize: 28, nameFamily: 'Arial', nameWeight: 700, nameStyle: 'normal', nameColor: '#000000', nameLine: 36, nameMaxWidth: 500, nameAlign: 'left', nameMaxLines: 2,
            rollX: 80, rollY: 460, rollSize: 20, rollFamily: 'Arial', rollWeight: 400, rollStyle: 'normal', rollColor: '#000000', rollLine: 24, rollMaxWidth: 300, rollAlign: 'left',
            barcodeX: 80, barcodeY: 520, barcodeW: 300, barcodeH: 60, barcodeFormat: 'CODE128'
        };
        let layout = JSON.parse(JSON.stringify(defaultLayout));

        const preview = document.getElementById('preview');
        const pctx = preview.getContext('2d');
        function $(id) { return document.getElementById(id); }

        $('templateFile').addEventListener('change', function (e) {
            const f = e.target.files[0];
            if (!f) return;
            const reader = new FileReader();
            reader.onload = ev => {
                templateImage = new Image();
                templateImage.onload = () => {
                    const maxW = 420, maxH = 600;
                    const scale = Math.min(maxW / templateImage.width, maxH / templateImage.height, 1);
                    preview.width = Math.round(templateImage.width * scale);
                    preview.height = Math.round(templateImage.height * scale);
                    $('cardW').value = templateImage.width;
                    $('cardH').value = templateImage.height;
                    drawPreview();
                    populateLeftInputsFromLayout();
                };
                templateImage.src = ev.target.result;
            };
            reader.readAsDataURL(f);
        });

        $('csvFile').addEventListener('change', (e) => {
            const f = e.target.files[0]; if (!f) return;
            Papa.parse(f, {
                header: true, skipEmptyLines: true, complete: (res) => {
                    csvRows = res.data;
                    csvHeaders = res.meta.fields || Object.keys(csvRows[0] || {});
                    populateMappingDropdowns();
                    livePreview();
                }
            });
        });

        function populateMappingDropdowns() {
            const selects = { mapPhoto: $('mapPhoto'), mapName: $('mapName'), mapID: $('mapID'), mapBarcode: $('mapBarcode') };
            Object.values(selects).forEach(s => {
                if (!s) return;
                s.innerHTML = '<option value="">â€” none â€”</option>';
                csvHeaders.forEach(h => s.insertAdjacentHTML('beforeend', `<option value="${h}">${h}</option>`));
            });

            function trySet(id, names) {
                const found = csvHeaders.find(h => names.includes(h.toLowerCase()));
                if (found && $(id)) $(id).value = found;
            }
            trySet('mapPhoto', ['profile', 'photo', 'image', 'picture', 'img', 'profilepicture', 'profile_image', 'profile_pic']);
            trySet('mapName', ['name', 'studentname', 'full_name', 'fullname']);
            trySet('mapID', ['id', 'rollno', 'roll', 'studentid', 'instituteid']);

            // default barcode source to mapped ID if present
            if ($('mapID') && $('mapBarcode')) $('mapBarcode').value = $('mapID').value || '';
        }

        function drawPreview() {
            pctx.clearRect(0, 0, preview.width, preview.height);
            if (templateImage) pctx.drawImage(templateImage, 0, 0, preview.width, preview.height);
            else { pctx.fillStyle = '#fff'; pctx.fillRect(0, 0, preview.width, preview.height); }
            if ($('snapToggle').checked) drawGrid();
            if (showOverlays) drawOverlays();
        }
        function drawGrid() {
            const grid = parseInt($('gridSize').value) || 10;
            pctx.save(); pctx.globalAlpha = 0.08; pctx.strokeStyle = '#000';
            for (let x = 0; x < preview.width; x += grid) { pctx.beginPath(); pctx.moveTo(x, 0); pctx.lineTo(x, preview.height); pctx.stroke(); }
            for (let y = 0; y < preview.height; y += grid) { pctx.beginPath(); pctx.moveTo(0, y); pctx.lineTo(preview.width, y); pctx.stroke(); }
            pctx.restore();
        }

        function actualToPreview(ax, ay) { if (!templateImage) return { x: ax, y: ay }; const sx = preview.width / templateImage.width; const sy = preview.height / templateImage.height; return { x: Math.round(ax * sx), y: Math.round(ay * sy) }; }
        function previewToActual(px, py) { if (!templateImage) return { x: px, y: py }; const sx = templateImage.width / preview.width; const sy = templateImage.height / preview.height; return { x: Math.round(px * sx), y: Math.round(py * sy) }; }

        function drawOverlays() {
            if (!templateImage) return;
            const scale = preview.width / templateImage.width;
            const p = actualToPreview(layout.photoX || defaultLayout.photoX, layout.photoY || defaultLayout.photoY);
            const psize = layout.photoSize || defaultLayout.photoSize;
            const r = Math.round(psize * scale);
            pctx.save(); pctx.globalAlpha = 0.28; pctx.fillStyle = '#d9534f';
            if (layout.photoShape === 'circle') { pctx.beginPath(); pctx.arc(p.x, p.y, r, 0, Math.PI * 2); pctx.fill(); }
            else pctx.fillRect(p.x - r, p.y - r, r * 2, r * 2);
            pctx.restore();

            pctx.save(); pctx.lineWidth = 3;
            pctx.strokeStyle = selectedElement === 'photo' ? 'rgba(0,123,255,0.95)' : 'rgba(0,0,0,0.12)';
            if (layout.photoShape === 'circle') { pctx.beginPath(); pctx.arc(p.x, p.y, r + (selectedElement === 'photo' ? 6 : 2), 0, Math.PI * 2); pctx.stroke(); }
            else pctx.strokeRect(p.x - r - (selectedElement === 'photo' ? 6 : 2), p.y - r - (selectedElement === 'photo' ? 6 : 2), (r * 2) + (selectedElement === 'photo' ? 12 : 4), (r * 2) + (selectedElement === 'photo' ? 12 : 4));
            pctx.restore();
            pctx.fillStyle = '#fff'; pctx.font = '12px Arial'; pctx.fillText('Photo', p.x + 8, p.y - 8);

            const textEls = ['name', 'roll'];
            textEls.forEach(el => {
                const ax = layout[el + 'X'] || defaultLayout[el + 'X'];
                const ay = layout[el + 'Y'] || defaultLayout[el + 'Y'];
                const pos = actualToPreview(ax, ay);
                const w = Math.max(60, Math.round((layout[el + 'MaxWidth'] || 200) * scale));
                const h = Math.round((layout[el + 'Line'] || 22) * 1.3);
                pctx.save(); pctx.globalAlpha = 0.16; pctx.fillStyle = el === 'name' ? 'rgba(0,123,255,0.85)' : 'rgba(0,0,0,0.6)';
                pctx.fillRect(pos.x, pos.y - h / 2, w, h);
                pctx.globalAlpha = 1; pctx.strokeStyle = selectedElement === el ? 'rgba(0,123,255,0.95)' : 'rgba(0,0,0,0.08)';
                pctx.lineWidth = selectedElement === el ? 3 : 1;
                pctx.strokeRect(pos.x - (selectedElement === el ? 4 : 0), pos.y - h / 2 - (selectedElement === el ? 4 : 0), w + (selectedElement === el ? 8 : 0), h + (selectedElement === el ? 8 : 0));
                pctx.fillStyle = '#fff'; pctx.font = '12px Arial'; pctx.fillText(el.charAt(0).toUpperCase() + el.slice(1), pos.x + 6, pos.y - (h / 2) + 4);
                pctx.restore();
            });

            // Barcode overlay
            const bx = layout.barcodeX || defaultLayout.barcodeX;
            const by = layout.barcodeY || defaultLayout.barcodeY;
            const bw = layout.barcodeW || defaultLayout.barcodeW;
            const bh = layout.barcodeH || defaultLayout.barcodeH;
            const ppos = actualToPreview(bx, by);
            pctx.save();
            pctx.globalAlpha = 0.18; pctx.fillStyle = 'rgba(0,0,0,0.85)';
            const pw = Math.round(bw * (preview.width / templateImage.width));
            const ph = Math.max(6, Math.round(bh * (preview.height / templateImage.height)));
            pctx.fillRect(ppos.x - Math.round(pw / 2), ppos.y - Math.round(ph / 2), pw, ph);
            pctx.globalAlpha = 1; pctx.strokeStyle = selectedElement === 'barcode' ? 'rgba(0,123,255,0.95)' : 'rgba(0,0,0,0.08)';
            pctx.lineWidth = selectedElement === 'barcode' ? 3 : 1;
            pctx.strokeRect(ppos.x - Math.round(pw / 2) - (selectedElement === 'barcode' ? 4 : 0), ppos.y - Math.round(ph / 2) - (selectedElement === 'barcode' ? 4 : 0), pw + (selectedElement === 'barcode' ? 8 : 0), ph + (selectedElement === 'barcode' ? 8 : 0));
            pctx.fillStyle = '#fff'; pctx.font = '12px Arial'; pctx.fillText('Barcode', ppos.x - Math.round(pw / 2) + 6, ppos.y - Math.round(ph / 2) - 6);
            pctx.restore();
        }

        function toggleOverlayLabels() { showOverlays = !showOverlays; drawPreview(); }

        function selectElement(el) {
            selectedElement = el;
            $('activeField').textContent = el.charAt(0).toUpperCase() + el.slice(1);
            document.querySelectorAll('.element-row').forEach(r => r.classList.remove('selected'));
            const row = document.getElementById('row-' + el); if (row) row.classList.add('selected');
            setActiveStyleInputs(); drawPreview();
        }

        preview.addEventListener('click', function (e) {
            const rect = preview.getBoundingClientRect();
            const px = e.clientX - rect.left, py = e.clientY - rect.top;
            if (placingElement) {
                const actual = previewToActual(px, py);
                placeAtActive(placingElement, actual.x, actual.y);
                placingElement = null; preview.style.cursor = 'default';
                drawPreview(); livePreview();
            }
        });

        function enterPlaceMode(el) { placingElement = el; preview.style.cursor = 'crosshair'; alert('Place mode: click on the preview to position "' + el + '". Press Esc to cancel.'); }

        document.addEventListener('keydown', function (e) {
            if (e.key === 'Escape' && placingElement) { placingElement = null; preview.style.cursor = 'default'; }
            if (!['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement.tagName)) {
                const step = e.shiftKey ? 10 : 1; let dx = 0, dy = 0;
                if (e.key === 'ArrowUp') { dy = -step; e.preventDefault(); }
                if (e.key === 'ArrowDown') { dy = step; e.preventDefault(); }
                if (e.key === 'ArrowLeft') { dx = -step; e.preventDefault(); }
                if (e.key === 'ArrowRight') { dx = step; e.preventDefault(); }
                if (dx || dy) nudgeElement(selectedElement, dx, dy);
            }
        });

        function placeAtActive(el, ax, ay) {
            if (el === 'photo') { layout.photoX = ax; layout.photoY = ay; $('photoX_input').value = layout.photoX; $('photoY_input').value = layout.photoY; }
            else if (el === 'roll') { layout.rollX = ax; layout.rollY = ay; $('rollX_input').value = layout.rollX; $('rollY_input').value = layout.rollY; }
            else if (el === 'barcode') { layout.barcodeX = ax; layout.barcodeY = ay; $('barcodeX_input').value = layout.barcodeX; $('barcodeY_input').value = layout.barcodeY; }
            else { layout[el + 'X'] = ax; layout[el + 'Y'] = ay; $(el + 'X_input').value = layout[el + 'X']; $(el + 'Y_input').value = layout[el + 'Y']; }
            drawPreview(); livePreview();
        }

        function nudgeElement(el, dx, dy) {
            if (el === 'photo') { layout.photoX = (layout.photoX || defaultLayout.photoX) + dx; layout.photoY = (layout.photoY || defaultLayout.photoY) + dy; $('photoX_input').value = layout.photoX; $('photoY_input').value = layout.photoY; }
            else if (el === 'roll') { layout.rollX = (layout.rollX || defaultLayout.rollX) + dx; layout.rollY = (layout.rollY || defaultLayout.rollY) + dy; $('rollX_input').value = layout.rollX; $('rollY_input').value = layout.rollY; }
            else if (el === 'barcode') { layout.barcodeX = (layout.barcodeX || defaultLayout.barcodeX) + dx; layout.barcodeY = (layout.barcodeY || defaultLayout.barcodeY) + dy; $('barcodeX_input').value = layout.barcodeX; $('barcodeY_input').value = layout.barcodeY; }
            else { layout[el + 'X'] = (layout[el + 'X'] || defaultLayout[el + 'X']) + dx; layout[el + 'Y'] = (layout[el + 'Y'] || defaultLayout[el + 'Y']) + dy; $(el + 'X_input').value = layout[el + 'X']; $(el + 'Y_input').value = layout[el + 'Y']; }
            drawPreview(); livePreview();
        }

        function wirePositionInputs() {
            const inputs = document.querySelectorAll('.pos-input');
            inputs.forEach(inp => inp.addEventListener('input', function () {
                const id = this.id.split('_')[0];
                const axis = id.endsWith('X') ? 'X' : 'Y';
                const el = id.replace(/X$|Y$/, '');
                const val = parseInt(this.value) || 0;
                if (el === 'photo') { if (axis === 'X') layout.photoX = val; else layout.photoY = val; }
                else if (el === 'roll') { if (axis === 'X') layout.rollX = val; else layout.rollY = val; }
                else if (el === 'barcode') { if (axis === 'X') layout.barcodeX = val; else layout.barcodeY = val; }
                else { layout[el + axis] = val; }
                drawPreview(); livePreview();
            }));
        }

        function updatePhotoSizeFromSlider(v) { const val = parseInt(v) || 80; $('photoSize_input').value = val; layout.photoSize = val; drawPreview(); livePreview(); }

        function snap(v) { if (!$('snapToggle').checked) return v; const g = parseInt($('gridSize').value) || 10; return Math.round(v / g) * g; }
        function snapAllToGrid() {
            ['photo', 'name', 'roll', 'barcode'].forEach(k => {
                if (k === 'photo') { layout.photoX = snap(layout.photoX || defaultLayout.photoX); layout.photoY = snap(layout.photoY || defaultLayout.photoY); layout.photoSize = snap(layout.photoSize || defaultLayout.photoSize); }
                else { layout[k + 'X'] = snap(layout[k + 'X'] || defaultLayout[k + 'X']); layout[k + 'Y'] = snap(layout[k + 'Y'] || defaultLayout[k + 'Y']); }
            });
            populateLeftInputsFromLayout(); drawPreview(); livePreview();
        }
        function resetAll() { layout = JSON.parse(JSON.stringify(defaultLayout)); populateLeftInputsFromLayout(); drawPreview(); livePreview(); }

        function setActiveStyleInputs() {
            const el = selectedElement || 'photo';
            $('activeField').textContent = el.charAt(0).toUpperCase() + el.slice(1);
            document.querySelectorAll('.element-row').forEach(r => r.classList.remove('selected'));
            const row = document.getElementById('row-' + el); if (row) row.classList.add('selected');

            if (el === 'photo') {
                $('photoSize').value = layout.photoSize || defaultLayout.photoSize; $('photoShape').value = layout.photoShape || defaultLayout.photoShape; $('photoBorder').value = layout.photoBorder || 0;
            } else if (el === 'barcode') {
                $('barcodeW').value = layout.barcodeW || defaultLayout.barcodeW; $('barcodeH').value = layout.barcodeH || defaultLayout.barcodeH; $('barcodeFormat').value = layout.barcodeFormat || defaultLayout.barcodeFormat;
            } else {
                const prefix = (el === 'roll') ? 'roll' : el;
                $('fontFamily').value = layout[prefix + 'Family'] || defaultLayout[prefix + 'Family'] || 'Arial';
                $('fontSize').value = layout[prefix + 'Size'] || defaultLayout[prefix + 'Size'] || (prefix === 'name' ? 28 : 18);
                $('fontWeight').value = layout[prefix + 'Weight'] || defaultLayout[prefix + 'Weight'] || 400;
                $('fontStyle').value = layout[prefix + 'Style'] || defaultLayout[prefix + 'Style'] || 'normal';
                $('fontColor').value = layout[prefix + 'Color'] || defaultLayout[prefix + 'Color'] || '#000000';
                $('lineHeight').value = layout[prefix + 'Line'] || defaultLayout[prefix + 'Line'] || (parseInt($('fontSize').value) + 6);
                $('maxWidth').value = layout[prefix + 'MaxWidth'] || defaultLayout[prefix + 'MaxWidth'] || 300;
                $('textAlign').value = layout[prefix + 'Align'] || defaultLayout[prefix + 'Align'] || 'left';
                $('autoFit').value = layout[prefix + 'AutoFit'] ? '1' : '0';
                $('maxLines').value = layout[prefix + 'MaxLines'] || defaultLayout[prefix + 'MaxLines'] || 2;
            }
        }

        function applyStyleToActive() {
            const el = selectedElement || 'photo';
            if (el === 'photo') {
                layout.photoSize = parseInt($('photoSize').value) || layout.photoSize; layout.photoShape = $('photoShape').value; layout.photoBorder = parseInt($('photoBorder').value) || 0; layout.photoBorderColor = layout.photoBorderColor || '#ffffff';
            } else if (el === 'barcode') {
                layout.barcodeW = parseInt($('barcodeW').value) || layout.barcodeW; layout.barcodeH = parseInt($('barcodeH').value) || layout.barcodeH; layout.barcodeFormat = $('barcodeFormat').value || layout.barcodeFormat;
            } else {
                const prefix = (el === 'roll') ? 'roll' : el;
                layout[prefix + 'Family'] = $('fontFamily').value; layout[prefix + 'Size'] = parseInt($('fontSize').value) || (prefix === 'name' ? 28 : 18);
                layout[prefix + 'Weight'] = $('fontWeight').value; layout[prefix + 'Style'] = $('fontStyle').value; layout[prefix + 'Color'] = $('fontColor').value;
                layout[prefix + 'Line'] = parseInt($('lineHeight').value) || (layout[prefix + 'Size'] + 6); layout[prefix + 'MaxWidth'] = parseInt($('maxWidth').value) || 300; layout[prefix + 'Align'] = $('textAlign').value; layout[prefix + 'AutoFit'] = $('autoFit').value === '1'; layout[prefix + 'MaxLines'] = parseInt($('maxLines').value) || 2;
            }
            drawPreview(); livePreview();
        }

        function applyStyleToAll() {
            const family = $('fontFamily').value; const size = parseInt($('fontSize').value) || 18;
            ['name', 'roll'].forEach(k => {
                const prefix = (k === 'roll') ? 'roll' : k;
                layout[prefix + 'Family'] = family; layout[prefix + 'Size'] = size; layout[prefix + 'Weight'] = $('fontWeight').value; layout[prefix + 'Style'] = $('fontStyle').value; layout[prefix + 'Color'] = $('fontColor').value;
                layout[prefix + 'Line'] = parseInt($('lineHeight').value) || 20; layout[prefix + 'MaxWidth'] = parseInt($('maxWidth').value) || 300; layout[prefix + 'Align'] = $('textAlign').value; layout[prefix + 'AutoFit'] = $('autoFit').value === '1'; layout[prefix + 'MaxLines'] = parseInt($('maxLines').value) || 2;
            });
            drawPreview(); livePreview();
        }

        function autoFitFont(ctx, text, maxWidth, initialSize, family, weight, style, minSize = 8, maxLines = 3) {
            let size = initialSize; let lines = [];
            while (size >= minSize) {
                ctx.font = `${weight} ${size}px ${family}`;
                lines = breakTextToLines(ctx, text, maxWidth, maxLines);
                const maxLineWidth = lines.reduce((m, l) => Math.max(m, ctx.measureText(l).width), 0);
                if (maxLineWidth <= maxWidth) break;
                size -= 1;
            }
            return { size, lines };
        }
        function breakTextToLines(ctx, text, maxWidth, maxLines) {
            const words = String(text).split(' ');
            const result = []; let line = '';
            for (let i = 0; i < words.length; i++) {
                const test = (line ? line + ' ' : '') + words[i];
                if (ctx.measureText(test).width > maxWidth && line) {
                    result.push(line); line = words[i];
                    if (result.length >= maxLines) break;
                } else line = test;
            }
            if (result.length < maxLines && line) result.push(line);
            if (result.length > maxLines) result.length = maxLines;
            if (result.length === maxLines && ctx.measureText(result[result.length - 1]).width > maxWidth) {
                let s = result[result.length - 1];
                while (ctx.measureText(s + '...').width > maxWidth && s.length) s = s.slice(0, -1);
                result[result.length - 1] = s.trim() + '...';
            }
            return result;
        }

        function processCSV() {
            if (!csvRows.length) { alert('Upload CSV first'); return; }
            if (!templateImage) { alert('Upload template first'); return; }
            generateAll(csvRows);
        }

        function generateAll(rows) {
            const container = $('cardsContainer'); container.innerHTML = '';
            rows.forEach((r, idx) => {
                const holder = document.createElement('div'); holder.className = 'card-preview';
                const canvas = document.createElement('canvas'); canvas.width = parseInt($('cardW').value) || layout.cardW; canvas.height = parseInt($('cardH').value) || layout.cardH; const ctx = canvas.getContext('2d');
                if (templateImage) ctx.drawImage(templateImage, 0, 0, canvas.width, canvas.height);
                else { ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, canvas.width, canvas.height); }

                const photoKey = $('mapPhoto').value; const photoUrl = photoKey ? (r[photoKey] || r[photoKey.toLowerCase()] || '') : '';
                if (photoUrl) {
                    const img = new Image(); img.crossOrigin = "anonymous";
                    img.onload = () => { drawPhotoOnCanvas(ctx, img, canvas); drawAllTextAndBarcode(ctx, r, canvas); };
                    img.onerror = () => { drawAllTextAndBarcode(ctx, r, canvas); };
                    img.src = photoUrl;
                } else { drawAllTextAndBarcode(ctx, r, canvas); }

                const btn = document.createElement('button'); btn.className = 'small-btn'; btn.textContent = 'Download';
                const nameForFile = sanitizeFilename((r[$('mapID').value] || `card-${idx + 1}`) + '_' + (r[$('mapName').value] || ''));
                btn.onclick = () => downloadCanvas(canvas, nameForFile);
                holder.appendChild(canvas); holder.appendChild(document.createElement('br')); holder.appendChild(btn); container.appendChild(holder);
            });
        }

        function drawPhotoOnCanvas(ctx, img, canvasEl) {
            ctx.save();
            const x = layout.photoX || defaultLayout.photoX, y = layout.photoY || defaultLayout.photoY, size = layout.photoSize || defaultLayout.photoSize;
            if (layout.photoShape === 'circle') {
                ctx.beginPath(); ctx.arc(x, y, size, 0, Math.PI * 2); ctx.closePath(); ctx.clip();
                ctx.drawImage(img, x - size, y - size, size * 2, size * 2); ctx.restore();
                if (layout.photoBorder > 0) { ctx.beginPath(); ctx.arc(x, y, size + layout.photoBorder / 2, 0, Math.PI * 2); ctx.lineWidth = layout.photoBorder; ctx.strokeStyle = layout.photoBorderColor; ctx.stroke(); }
            } else if (layout.photoShape === 'rectangle') {
                const w = size, h = size; ctx.drawImage(img, x - w / 2, y - h / 2, w, h);
                if (layout.photoBorder > 0) { ctx.lineWidth = layout.photoBorder; ctx.strokeStyle = layout.photoBorderColor; ctx.strokeRect(x - w / 2, y - h / 2, w, h); }
            } else {
                const w = size, h = size, r = layout.photoRadius || 12; roundRectClip(ctx, x - w / 2, y - h / 2, w, h, r);
                ctx.drawImage(img, x - w / 2, y - h / 2, w, h); ctx.restore();
                if (layout.photoBorder > 0) roundRectStroke(ctx, x - w / 2, y - h / 2, w, h, r, layout.photoBorder, layout.photoBorderColor);
            }
        }

        function roundRectClip(ctx, x, y, w, h, r) {
            ctx.beginPath(); ctx.moveTo(x + r, y); ctx.lineTo(x + w - r, y); ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r); ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h); ctx.quadraticCurveTo(x, y + h, x, y + h - r); ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y); ctx.closePath(); ctx.clip();
        }
        function roundRectStroke(ctx, x, y, w, h, r, border, color) {
            ctx.save(); ctx.beginPath(); ctx.moveTo(x + r, y); ctx.lineTo(x + w - r, y); ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r); ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h); ctx.quadraticCurveTo(x, y + h, x, y + h - r); ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y); ctx.closePath(); ctx.lineWidth = border; ctx.strokeStyle = color; ctx.stroke(); ctx.restore();
        }

        function drawAllTextAndBarcode(ctx, row, canvasEl) {
            drawAllTextOnCanvas(ctx, row);
            drawBarcodeOnCanvas(ctx, row);
        }

        function drawAllTextOnCanvas(ctx, row) {
            const read = k => { const map = { Name: 'mapName', ID: 'mapID' }; const sel = $(map[k]).value; return sel ? (row[sel] || row[sel.toLowerCase()] || '') : ''; };
            const fieldSpecs = [{ key: 'name', label: read('Name') || '', prefix: 'name' }, { key: 'roll', label: read('ID') || '', prefix: 'roll' }];
            fieldSpecs.forEach(f => {
                if (!f.label) return;
                const prefix = f.prefix;
                const x = layout[prefix + 'X'] || defaultLayout[prefix + 'X'];
                const y = layout[prefix + 'Y'] || defaultLayout[prefix + 'Y'];
                const family = layout[prefix + 'Family'] || defaultLayout[prefix + 'Family'] || 'Arial';
                const initSize = layout[prefix + 'Size'] || defaultLayout[prefix + 'Size'] || 18;
                const weight = layout[prefix + 'Weight'] || defaultLayout[prefix + 'Weight'] || 400;
                const style = layout[prefix + 'Style'] || 'normal';
                const color = layout[prefix + 'Color'] || defaultLayout[prefix + 'Color'] || '#000';
                const line = layout[prefix + 'Line'] || defaultLayout[prefix + 'Line'] || (initSize + 6);
                const maxWidth = layout[prefix + 'MaxWidth'] || defaultLayout[prefix + 'MaxWidth'];
                const align = layout[prefix + 'Align'] || defaultLayout[prefix + 'Align'] || 'left';
                const autoFit = layout[prefix + 'AutoFit'] === undefined ? true : !!layout[prefix + 'AutoFit'];
                const maxLines = layout[prefix + 'MaxLines'] || defaultLayout[prefix + 'MaxLines'] || 3;
                ctx.fillStyle = color;
                if (maxWidth && autoFit) {
                    const { size, lines } = autoFitFont(ctx, f.label, maxWidth, initSize, family, weight, style, 8, maxLines);
                    ctx.font = `${weight} ${size}px ${family}`; ctx.textBaseline = 'top';
                    let yy = y; lines.forEach(lineText => { drawAlignedText(ctx, lineText, x, yy, align); yy += (layout[prefix + 'Line'] || line); });
                } else {
                    ctx.font = `${weight} ${initSize}px ${family}`; ctx.textBaseline = 'top';
                    const lines = breakTextToLines(ctx, f.label, maxWidth || 1000, maxLines);
                    let yy = y; lines.forEach(lineText => { drawAlignedText(ctx, lineText, x, yy, align); yy += (layout[prefix + 'Line'] || line); });
                }
            });
        }

        function drawAlignedText(ctx, text, x, y, align = 'left') {
            const metrics = ctx.measureText(text); const w = metrics.width;
            if (align === 'center') ctx.fillText(text, x - w / 2, y);
            else if (align === 'right') ctx.fillText(text, x - w, y);
            else ctx.fillText(text, x, y);
        }

        function drawBarcodeOnCanvas(ctx, row) {
            // get barcode source: prefer mapBarcode, fallback to mapID
            const barcodeMap = $('mapBarcode') ? ($('mapBarcode').value || $('mapID').value) : $('mapID').value;
            const idValue = barcodeMap ? (row[barcodeMap] || row[barcodeMap.toLowerCase()] || '') : '';
            if (!idValue) return;
            const bw = layout.barcodeW || defaultLayout.barcodeW;
            const bh = layout.barcodeH || defaultLayout.barcodeH;
            const bx = layout.barcodeX || defaultLayout.barcodeX;
            const by = layout.barcodeY || defaultLayout.barcodeY;
            const format = layout.barcodeFormat || defaultLayout.barcodeFormat;

            try {
                const tempCanvas = document.createElement('canvas'); tempCanvas.width = bw; tempCanvas.height = bh;
                // render without the human-readable text (displayValue:false)
                JsBarcode(tempCanvas, String(idValue), { format: format, displayValue: false, height: bh, width: 1, margin: 0 });
                const dx = Math.round(bx - bw / 2);
                const dy = Math.round(by - bh / 2);
                ctx.drawImage(tempCanvas, dx, dy, bw, bh);
            } catch (err) {
                console.warn('Barcode render failed', err);
            }
        }

        function downloadCanvas(canvas, name) { canvas.toBlob(blob => { saveAs(blob, `${name}.png`); }); }
        function sanitizeFilename(s) { try { return s.toString().trim().replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_\-\.]/g, ''); } catch (e) { return 'card'; } }

        async function renderCardBlobForRow(row, index) {
            const cw = parseInt($('cardW').value) || layout.cardW; const ch = parseInt($('cardH').value) || layout.cardH;
            const canvas = document.createElement('canvas'); canvas.width = cw; canvas.height = ch; const ctx = canvas.getContext('2d');
            if (templateImage) ctx.drawImage(templateImage, 0, 0, canvas.width, canvas.height); else { ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, canvas.width, canvas.height); }

            const photoKey = $('mapPhoto').value; const photoUrl = photoKey ? (row[photoKey] || row[photoKey.toLowerCase()] || '') : '';
            if (photoUrl) {
                try {
                    const img = await loadImagePromise(photoUrl);
                    ctx.save();
                    const x = layout.photoX || defaultLayout.photoX, y = layout.photoY || defaultLayout.photoY, size = layout.photoSize || defaultLayout.photoSize;
                    if (layout.photoShape === 'circle') {
                        ctx.beginPath(); ctx.arc(x, y, size, 0, Math.PI * 2); ctx.closePath(); ctx.clip();
                        ctx.drawImage(img, x - size, y - size, size * 2, size * 2); ctx.restore();
                        if (layout.photoBorder > 0) { ctx.beginPath(); ctx.arc(x, y, size + layout.photoBorder / 2, 0, Math.PI * 2); ctx.lineWidth = layout.photoBorder; ctx.strokeStyle = layout.photoBorderColor; ctx.stroke(); }
                    } else if (layout.photoShape === 'rectangle') {
                        const w = size, h = size; ctx.drawImage(img, x - w / 2, y - h / 2, w, h);
                        if (layout.photoBorder > 0) { ctx.lineWidth = layout.photoBorder; ctx.strokeStyle = layout.photoBorderColor; ctx.strokeRect(x - w / 2, y - h / 2, w, h); }
                    } else {
                        const w = size, h = size, r = layout.photoRadius || 12; roundRectClip(ctx, x - w / 2, y - h / 2, w, h, r);
                        ctx.drawImage(img, x - w / 2, y - h / 2, w, h); ctx.restore();
                        if (layout.photoBorder > 0) roundRectStroke(ctx, x - w / 2, y - h / 2, w, h, r, layout.photoBorder, layout.photoBorderColor);
                    }
                } catch (err) { }
            }

            drawAllTextOnCanvas(ctx, row);
            drawBarcodeOnCanvas(ctx, row);

            return new Promise(resolve => canvas.toBlob(blob => resolve(blob), 'image/png'));
        }

        function loadImagePromise(url) { return new Promise((resolve, reject) => { if (!url) { reject('no-url'); return; } const img = new Image(); img.crossOrigin = "anonymous"; img.onload = () => resolve(img); img.onerror = () => reject('img-error'); img.src = url; }); }

        async function downloadAllZip() {
            if (!csvRows.length) { alert('Upload CSV first'); return; }
            if (!templateImage) { alert('Upload template first'); return; }
            const zip = new JSZip(); const folder = zip.folder('idcards') || zip; const total = csvRows.length; let failed = 0;
            for (let i = 0; i < total; i++) {
                const row = csvRows[i];
                try {
                    const blob = await renderCardBlobForRow(row, i);
                    const idVal = (row[$('mapID').value] || `card-${i + 1}`).toString();
                    const nameVal = (row[$('mapName').value] || '').toString();
                    const filename = sanitizeFilename(idVal + '_' + nameVal) || `card-${i + 1}`;
                    folder.file(`${filename}.png`, blob);
                } catch (e) { failed++; }
            }
            const content = await zip.generateAsync({ type: 'blob' });
            saveAs(content, 'idcards.zip');
        }

        function exportLayout() {
            const out = {
                layout,
                maps: {
                    photo: $('mapPhoto') ? $('mapPhoto').value : '',
                    name: $('mapName') ? $('mapName').value : '',
                    id: $('mapID') ? $('mapID').value : '',
                    barcode: $('mapBarcode') ? $('mapBarcode').value : ''
                }
            };
            const blob = new Blob([JSON.stringify(out, null, 2)], { type: 'application/json' });
            const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'idcard-layout.json'; a.click();
        }

        function importLayoutFile(e) {
            const f = e.target.files ? e.target.files[0] : null;
            if (!f) { alert('No file selected'); return; }
            const r = new FileReader();
            r.onload = ev => {
                try {
                    const obj = JSON.parse(ev.target.result);
                    if (!obj.layout) { alert('JSON missing `layout` object'); return; }
                    // merge (keeps current keys if not specified)
                    layout = Object.assign({}, layout, obj.layout);

                    if (obj.maps) {
                        if ($('mapPhoto')) $('mapPhoto').value = obj.maps.photo || '';
                        if ($('mapName')) $('mapName').value = obj.maps.name || '';
                        if ($('mapID')) $('mapID').value = obj.maps.id || '';
                        if ($('mapBarcode')) $('mapBarcode').value = obj.maps.barcode || '';
                    }

                    populateLeftInputsFromLayout();
                    drawPreview();
                    livePreview();
                    alert('Layout imported');
                } catch (err) {
                    console.error(err); alert('Invalid JSON file');
                }
            };
            r.readAsText(f);
        }

        function saveLayoutLocal() {
            localStorage.setItem('idcard_layout', JSON.stringify({
                layout,
                maps: { photo: $('mapPhoto').value, name: $('mapName').value, id: $('mapID').value, barcode: $('mapBarcode') ? $('mapBarcode').value : '' }
            }));
            alert('Layout saved locally');
        }
        function loadSavedLayout() {
            const s = localStorage.getItem('idcard_layout'); if (!s) { alert('No saved layout'); return; }
            const obj = JSON.parse(s); if (obj.layout) layout = obj.layout;
            if (obj.maps) {
                if ($('mapPhoto')) $('mapPhoto').value = obj.maps.photo || '';
                if ($('mapName')) $('mapName').value = obj.maps.name || '';
                if ($('mapID')) $('mapID').value = obj.maps.id || '';
                if ($('mapBarcode') && obj.maps.barcode) $('mapBarcode').value = obj.maps.barcode || '';
            }
            populateLeftInputsFromLayout(); drawPreview(); livePreview(); alert('Layout loaded');
        }

        function livePreview() {
            const first = csvRows.length ? csvRows[0] : { name: 'Sample Name', id: '000', profile: '', dob: '2000-01-01', bloodgroup: 'O+', contactno: '0000000000', address: 'Sample address' };
            renderSingleOnPreview(first, true);
        }
        function renderSingleOnPreview(row, isLive = false) {
            const cw = parseInt($('cardW').value) || layout.cardW, ch = parseInt($('cardH').value) || layout.cardH;
            const canvas = document.createElement('canvas'); canvas.width = cw; canvas.height = ch; const ctx = canvas.getContext('2d');
            if (templateImage) ctx.drawImage(templateImage, 0, 0, canvas.width, canvas.height); else { ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, canvas.width, canvas.height); }
            const photoKey = $('mapPhoto').value; const photoUrl = photoKey ? (row[photoKey] || row[photoKey.toLowerCase()] || '') : '';
            if (photoUrl) {
                const img = new Image(); img.crossOrigin = "anonymous";
                img.onload = () => { drawPhotoOnCanvas(ctx, img, canvas); drawAllTextOnCanvas(ctx, row); drawBarcodeOnCanvas(ctx, row); appendPreview(canvas, isLive); };
                img.onerror = () => { drawAllTextOnCanvas(ctx, row); drawBarcodeOnCanvas(ctx, row); appendPreview(canvas, isLive); };
                img.src = photoUrl;
            } else { drawAllTextOnCanvas(ctx, row); drawBarcodeOnCanvas(ctx, row); appendPreview(canvas, isLive); }
        }
        function appendPreview(canvas, isLive) {
            const container = $('cardsContainer');
            if (isLive) {
                const prev = document.getElementById('__live_preview'); if (prev) prev.remove();
                const holder = document.createElement('div'); holder.className = 'card-preview'; holder.id = '__live_preview';
                const el = document.createElement('canvas'); el.width = canvas.width; el.height = canvas.height; el.style.width = '100%';
                el.getContext('2d').drawImage(canvas, 0, 0);
                const btn = document.createElement('button'); btn.className = 'small-btn'; btn.textContent = 'Download Sample'; btn.onclick = () => downloadCanvas(el, 'sample');
                holder.appendChild(el); holder.appendChild(document.createElement('br')); holder.appendChild(btn); container.prepend(holder);
            }
        }

        function populateLeftInputsFromLayout() {
            $('photoX_input').value = layout.photoX; $('photoY_input').value = layout.photoY;
            $('nameX_input').value = layout.nameX; $('nameY_input').value = layout.nameY;
            $('rollX_input').value = layout.rollX; $('rollY_input').value = layout.rollY;
            $('barcodeX_input').value = layout.barcodeX; $('barcodeY_input').value = layout.barcodeY;
            $('photoSize_input').value = layout.photoSize; $('photoSize').value = layout.photoSize;
        }

        function init() {
            wirePositionInputs();
            document.querySelectorAll('.element-row').forEach(row => row.addEventListener('click', () => { const el = row.dataset.el; if (el) selectElement(el); }));
            ['fontFamily', 'fontSize', 'fontWeight', 'fontStyle', 'fontColor', 'lineHeight', 'maxWidth', 'textAlign', 'autoFit', 'maxLines'].forEach(id => {
                const el = $(id); if (el) el.addEventListener('input', () => { });
            });
            $('photoSize').addEventListener('input', () => { $('photoSize_input').value = $('photoSize').value; layout.photoSize = parseInt($('photoSize').value) || layout.photoSize; drawPreview(); livePreview(); });
            ['mapPhoto', 'mapName', 'mapID', 'mapBarcode'].forEach(id => { const el = $(id); if (el) el.addEventListener('change', () => livePreview()); });

            // barcode controls
            ['barcodeW', 'barcodeH', 'barcodeFormat'].forEach(id => {
                const el = $(id); if (el) el.addEventListener('input', () => {
                    layout.barcodeW = parseInt($('barcodeW').value) || layout.barcodeW;
                    layout.barcodeH = parseInt($('barcodeH').value) || layout.barcodeH;
                    layout.barcodeFormat = $('barcodeFormat').value || layout.barcodeFormat;
                    drawPreview(); livePreview();
                });
            });

            setTimeout(() => { selectElement('photo'); setActiveStyleInputs(); drawPreview(); livePreview(); }, 150);
        }
        setTimeout(init, 200);
    </script>
</body>

</html>